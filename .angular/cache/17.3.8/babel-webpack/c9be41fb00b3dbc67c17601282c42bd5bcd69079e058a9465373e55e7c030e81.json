{"ast":null,"code":"/*!\n * iro.js v5.5.2\n * 2016-2021 James Daniel\n * Licensed under MPL 2.0\n * github.com/jaames/iro.js\n */\n\nvar n,\n  u,\n  t,\n  i,\n  r,\n  o,\n  f = {},\n  e = [],\n  c = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;\nfunction s(n, l) {\n  for (var u in l) {\n    n[u] = l[u];\n  }\n  return n;\n}\nfunction a(n) {\n  var l = n.parentNode;\n  l && l.removeChild(n);\n}\nfunction h(n, l, u) {\n  var t,\n    i,\n    r,\n    o,\n    f = arguments;\n  if (l = s({}, l), arguments.length > 3) {\n    for (u = [u], t = 3; t < arguments.length; t++) {\n      u.push(f[t]);\n    }\n  }\n  if (null != u && (l.children = u), null != n && null != n.defaultProps) {\n    for (i in n.defaultProps) {\n      void 0 === l[i] && (l[i] = n.defaultProps[i]);\n    }\n  }\n  return o = l.key, null != (r = l.ref) && delete l.ref, null != o && delete l.key, v(n, l, o, r);\n}\nfunction v(l, u, t, i) {\n  var r = {\n    type: l,\n    props: u,\n    key: t,\n    ref: i,\n    __k: null,\n    __p: null,\n    __b: 0,\n    __e: null,\n    l: null,\n    __c: null,\n    constructor: void 0\n  };\n  return n.vnode && n.vnode(r), r;\n}\nfunction d(n) {\n  return n.children;\n}\nfunction y(n) {\n  if (null == n || \"boolean\" == typeof n) {\n    return null;\n  }\n  if (\"string\" == typeof n || \"number\" == typeof n) {\n    return v(null, n, null, null);\n  }\n  if (null != n.__e || null != n.__c) {\n    var l = v(n.type, n.props, n.key, null);\n    return l.__e = n.__e, l;\n  }\n  return n;\n}\nfunction m(n, l) {\n  this.props = n, this.context = l;\n}\nfunction w(n, l) {\n  if (null == l) {\n    return n.__p ? w(n.__p, n.__p.__k.indexOf(n) + 1) : null;\n  }\n  for (var u; l < n.__k.length; l++) {\n    if (null != (u = n.__k[l]) && null != u.__e) {\n      return u.__e;\n    }\n  }\n  return \"function\" == typeof n.type ? w(n) : null;\n}\nfunction g(n) {\n  var l, u;\n  if (null != (n = n.__p) && null != n.__c) {\n    for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) {\n      if (null != (u = n.__k[l]) && null != u.__e) {\n        n.__e = n.__c.base = u.__e;\n        break;\n      }\n    }\n    return g(n);\n  }\n}\nfunction k(l) {\n  (!l.__d && (l.__d = !0) && 1 === u.push(l) || i !== n.debounceRendering) && (i = n.debounceRendering, (n.debounceRendering || t)(_));\n}\nfunction _() {\n  var n, l, t, i, r, o, f, e;\n  for (u.sort(function (n, l) {\n    return l.__v.__b - n.__v.__b;\n  }); n = u.pop();) {\n    n.__d && (t = void 0, i = void 0, o = (r = (l = n).__v).__e, f = l.__P, e = l.u, l.u = !1, f && (t = [], i = $(f, r, s({}, r), l.__n, void 0 !== f.ownerSVGElement, null, t, e, null == o ? w(r) : o), j(t, r), i != o && g(r)));\n  }\n}\nfunction b(n, l, u, t, i, r, o, c, s) {\n  var h,\n    v,\n    p,\n    d,\n    y,\n    m,\n    g,\n    k = u && u.__k || e,\n    _ = k.length;\n  if (c == f && (c = null != r ? r[0] : _ ? w(u, 0) : null), h = 0, l.__k = x(l.__k, function (u) {\n    if (null != u) {\n      if (u.__p = l, u.__b = l.__b + 1, null === (p = k[h]) || p && u.key == p.key && u.type === p.type) {\n        k[h] = void 0;\n      } else {\n        for (v = 0; v < _; v++) {\n          if ((p = k[v]) && u.key == p.key && u.type === p.type) {\n            k[v] = void 0;\n            break;\n          }\n          p = null;\n        }\n      }\n      if (d = $(n, u, p = p || f, t, i, r, o, null, c, s), (v = u.ref) && p.ref != v && (g || (g = [])).push(v, u.__c || d, u), null != d) {\n        if (null == m && (m = d), null != u.l) {\n          d = u.l, u.l = null;\n        } else if (r == p || d != c || null == d.parentNode) {\n          n: if (null == c || c.parentNode !== n) {\n            n.appendChild(d);\n          } else {\n            for (y = c, v = 0; (y = y.nextSibling) && v < _; v += 2) {\n              if (y == d) {\n                break n;\n              }\n            }\n            n.insertBefore(d, c);\n          }\n          \"option\" == l.type && (n.value = \"\");\n        }\n        c = d.nextSibling, \"function\" == typeof l.type && (l.l = d);\n      }\n    }\n    return h++, u;\n  }), l.__e = m, null != r && \"function\" != typeof l.type) {\n    for (h = r.length; h--;) {\n      null != r[h] && a(r[h]);\n    }\n  }\n  for (h = _; h--;) {\n    null != k[h] && D(k[h], k[h]);\n  }\n  if (g) {\n    for (h = 0; h < g.length; h++) {\n      A(g[h], g[++h], g[++h]);\n    }\n  }\n}\nfunction x(n, l, u) {\n  if (null == u && (u = []), null == n || \"boolean\" == typeof n) {\n    l && u.push(l(null));\n  } else if (Array.isArray(n)) {\n    for (var t = 0; t < n.length; t++) {\n      x(n[t], l, u);\n    }\n  } else {\n    u.push(l ? l(y(n)) : n);\n  }\n  return u;\n}\nfunction C(n, l, u, t, i) {\n  var r;\n  for (r in u) {\n    r in l || N(n, r, null, u[r], t);\n  }\n  for (r in l) {\n    i && \"function\" != typeof l[r] || \"value\" === r || \"checked\" === r || u[r] === l[r] || N(n, r, l[r], u[r], t);\n  }\n}\nfunction P(n, l, u) {\n  \"-\" === l[0] ? n.setProperty(l, u) : n[l] = \"number\" == typeof u && !1 === c.test(l) ? u + \"px\" : null == u ? \"\" : u;\n}\nfunction N(n, l, u, t, i) {\n  var r, o, f, e, c;\n  if (\"key\" === (l = i ? \"className\" === l ? \"class\" : l : \"class\" === l ? \"className\" : l) || \"children\" === l) ;else if (\"style\" === l) {\n    if (r = n.style, \"string\" == typeof u) {\n      r.cssText = u;\n    } else {\n      if (\"string\" == typeof t && (r.cssText = \"\", t = null), t) {\n        for (o in t) {\n          u && o in u || P(r, o, \"\");\n        }\n      }\n      if (u) {\n        for (f in u) {\n          t && u[f] === t[f] || P(r, f, u[f]);\n        }\n      }\n    }\n  } else {\n    \"o\" === l[0] && \"n\" === l[1] ? (e = l !== (l = l.replace(/Capture$/, \"\")), c = l.toLowerCase(), l = (c in n ? c : l).slice(2), u ? (t || n.addEventListener(l, T, e), (n.t || (n.t = {}))[l] = u) : n.removeEventListener(l, T, e)) : \"list\" !== l && \"tagName\" !== l && \"form\" !== l && !i && l in n ? n[l] = null == u ? \"\" : u : \"function\" != typeof u && \"dangerouslySetInnerHTML\" !== l && (l !== (l = l.replace(/^xlink:?/, \"\")) ? null == u || !1 === u ? n.removeAttributeNS(\"http://www.w3.org/1999/xlink\", l.toLowerCase()) : n.setAttributeNS(\"http://www.w3.org/1999/xlink\", l.toLowerCase(), u) : null == u || !1 === u ? n.removeAttribute(l) : n.setAttribute(l, u));\n  }\n}\nfunction T(l) {\n  return this.t[l.type](n.event ? n.event(l) : l);\n}\nfunction $(l, u, t, i, r, o, f, e, c, a) {\n  var h,\n    v,\n    p,\n    y,\n    w,\n    g,\n    k,\n    _,\n    C,\n    P,\n    N = u.type;\n  if (void 0 !== u.constructor) {\n    return null;\n  }\n  (h = n.__b) && h(u);\n  try {\n    n: if (\"function\" == typeof N) {\n      if (_ = u.props, C = (h = N.contextType) && i[h.__c], P = h ? C ? C.props.value : h.__p : i, t.__c ? k = (v = u.__c = t.__c).__p = v.__E : (\"prototype\" in N && N.prototype.render ? u.__c = v = new N(_, P) : (u.__c = v = new m(_, P), v.constructor = N, v.render = H), C && C.sub(v), v.props = _, v.state || (v.state = {}), v.context = P, v.__n = i, p = v.__d = !0, v.__h = []), null == v.__s && (v.__s = v.state), null != N.getDerivedStateFromProps && s(v.__s == v.state ? v.__s = s({}, v.__s) : v.__s, N.getDerivedStateFromProps(_, v.__s)), p) {\n        null == N.getDerivedStateFromProps && null != v.componentWillMount && v.componentWillMount(), null != v.componentDidMount && f.push(v);\n      } else {\n        if (null == N.getDerivedStateFromProps && null == e && null != v.componentWillReceiveProps && v.componentWillReceiveProps(_, P), !e && null != v.shouldComponentUpdate && !1 === v.shouldComponentUpdate(_, v.__s, P)) {\n          for (v.props = _, v.state = v.__s, v.__d = !1, v.__v = u, u.__e = null != c ? c !== t.__e ? c : t.__e : null, u.__k = t.__k, h = 0; h < u.__k.length; h++) {\n            u.__k[h] && (u.__k[h].__p = u);\n          }\n          break n;\n        }\n        null != v.componentWillUpdate && v.componentWillUpdate(_, v.__s, P);\n      }\n      for (y = v.props, w = v.state, v.context = P, v.props = _, v.state = v.__s, (h = n.__r) && h(u), v.__d = !1, v.__v = u, v.__P = l, h = v.render(v.props, v.state, v.context), u.__k = x(null != h && h.type == d && null == h.key ? h.props.children : h), null != v.getChildContext && (i = s(s({}, i), v.getChildContext())), p || null == v.getSnapshotBeforeUpdate || (g = v.getSnapshotBeforeUpdate(y, w)), b(l, u, t, i, r, o, f, c, a), v.base = u.__e; h = v.__h.pop();) {\n        v.__s && (v.state = v.__s), h.call(v);\n      }\n      p || null == y || null == v.componentDidUpdate || v.componentDidUpdate(y, w, g), k && (v.__E = v.__p = null);\n    } else {\n      u.__e = z(t.__e, u, t, i, r, o, f, a);\n    }\n    (h = n.diffed) && h(u);\n  } catch (l) {\n    n.__e(l, u, t);\n  }\n  return u.__e;\n}\nfunction j(l, u) {\n  for (var t; t = l.pop();) {\n    try {\n      t.componentDidMount();\n    } catch (l) {\n      n.__e(l, t.__v);\n    }\n  }\n  n.__c && n.__c(u);\n}\nfunction z(n, l, u, t, i, r, o, c) {\n  var s,\n    a,\n    h,\n    v,\n    p = u.props,\n    d = l.props;\n  if (i = \"svg\" === l.type || i, null == n && null != r) {\n    for (s = 0; s < r.length; s++) {\n      if (null != (a = r[s]) && (null === l.type ? 3 === a.nodeType : a.localName === l.type)) {\n        n = a, r[s] = null;\n        break;\n      }\n    }\n  }\n  if (null == n) {\n    if (null === l.type) {\n      return document.createTextNode(d);\n    }\n    n = i ? document.createElementNS(\"http://www.w3.org/2000/svg\", l.type) : document.createElement(l.type), r = null;\n  }\n  return null === l.type ? p !== d && (null != r && (r[r.indexOf(n)] = null), n.data = d) : l !== u && (null != r && (r = e.slice.call(n.childNodes)), h = (p = u.props || f).dangerouslySetInnerHTML, v = d.dangerouslySetInnerHTML, c || (v || h) && (v && h && v.__html == h.__html || (n.innerHTML = v && v.__html || \"\")), C(n, d, p, i, c), l.__k = l.props.children, v || b(n, l, u, t, \"foreignObject\" !== l.type && i, r, o, f, c), c || (\"value\" in d && void 0 !== d.value && d.value !== n.value && (n.value = null == d.value ? \"\" : d.value), \"checked\" in d && void 0 !== d.checked && d.checked !== n.checked && (n.checked = d.checked))), n;\n}\nfunction A(l, u, t) {\n  try {\n    \"function\" == typeof l ? l(u) : l.current = u;\n  } catch (l) {\n    n.__e(l, t);\n  }\n}\nfunction D(l, u, t) {\n  var i, r, o;\n  if (n.unmount && n.unmount(l), (i = l.ref) && A(i, null, u), t || \"function\" == typeof l.type || (t = null != (r = l.__e)), l.__e = l.l = null, null != (i = l.__c)) {\n    if (i.componentWillUnmount) {\n      try {\n        i.componentWillUnmount();\n      } catch (l) {\n        n.__e(l, u);\n      }\n    }\n    i.base = i.__P = null;\n  }\n  if (i = l.__k) {\n    for (o = 0; o < i.length; o++) {\n      i[o] && D(i[o], u, t);\n    }\n  }\n  null != r && a(r);\n}\nfunction H(n, l, u) {\n  return this.constructor(n, u);\n}\nfunction I(l, u, t) {\n  var i, o, c;\n  n.__p && n.__p(l, u), o = (i = t === r) ? null : t && t.__k || u.__k, l = h(d, null, [l]), c = [], $(u, i ? u.__k = l : (t || u).__k = l, o || f, f, void 0 !== u.ownerSVGElement, t && !i ? [t] : o ? null : e.slice.call(u.childNodes), c, !1, t || f, i), j(c, l);\n}\nn = {}, m.prototype.setState = function (n, l) {\n  var u = this.__s !== this.state && this.__s || (this.__s = s({}, this.state));\n  (\"function\" != typeof n || (n = n(u, this.props))) && s(u, n), null != n && this.__v && (this.u = !1, l && this.__h.push(l), k(this));\n}, m.prototype.forceUpdate = function (n) {\n  this.__v && (n && this.__h.push(n), this.u = !0, k(this));\n}, m.prototype.render = d, u = [], t = \"function\" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, i = n.debounceRendering, n.__e = function (n, l, u) {\n  for (var t; l = l.__p;) {\n    if ((t = l.__c) && !t.__p) {\n      try {\n        if (t.constructor && null != t.constructor.getDerivedStateFromError) {\n          t.setState(t.constructor.getDerivedStateFromError(n));\n        } else {\n          if (null == t.componentDidCatch) {\n            continue;\n          }\n          t.componentDidCatch(n);\n        }\n        return k(t.__E = t);\n      } catch (l) {\n        n = l;\n      }\n    }\n  }\n  throw n;\n}, r = f, o = 0;\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) {\n      descriptor.writable = true;\n    }\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) {\n    _defineProperties(Constructor.prototype, protoProps);\n  }\n  if (staticProps) {\n    _defineProperties(Constructor, staticProps);\n  }\n  return Constructor;\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    var arguments$1 = arguments;\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments$1[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// Some regular expressions for rgb() and hsl() Colors are borrowed from tinyColor\n// https://github.com/bgrins/TinyColor\n// Kelvin temperature math borrowed from Neil Barlett's implementation\n// from https://github.com/neilbartlett/color-temperature\n// https://www.w3.org/TR/css3-values/#integers\nvar CSS_INTEGER = '[-\\\\+]?\\\\d+%?'; // http://www.w3.org/TR/css3-values/#number-value\n\nvar CSS_NUMBER = '[-\\\\+]?\\\\d*\\\\.\\\\d+%?'; // Allow positive/negative integer/number. Don't capture the either/or, just the entire outcome\n\nvar CSS_UNIT = '(?:' + CSS_NUMBER + ')|(?:' + CSS_INTEGER + ')'; // Parse function params\n// Parens and commas are optional, and this also allows for whitespace between numbers\n\nvar PERMISSIVE_MATCH_3 = '[\\\\s|\\\\(]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')\\\\s*\\\\)?';\nvar PERMISSIVE_MATCH_4 = '[\\\\s|\\\\(]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')\\\\s*\\\\)?'; // Regex patterns for functional color strings\n\nvar REGEX_FUNCTIONAL_RGB = new RegExp('rgb' + PERMISSIVE_MATCH_3);\nvar REGEX_FUNCTIONAL_RGBA = new RegExp('rgba' + PERMISSIVE_MATCH_4);\nvar REGEX_FUNCTIONAL_HSL = new RegExp('hsl' + PERMISSIVE_MATCH_3);\nvar REGEX_FUNCTIONAL_HSLA = new RegExp('hsla' + PERMISSIVE_MATCH_4); // Color string parsing regex\n\nvar HEX_START = '^(?:#?|0x?)';\nvar HEX_INT_SINGLE = '([0-9a-fA-F]{1})';\nvar HEX_INT_DOUBLE = '([0-9a-fA-F]{2})';\nvar REGEX_HEX_3 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + '$');\nvar REGEX_HEX_4 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + '$');\nvar REGEX_HEX_6 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + '$');\nvar REGEX_HEX_8 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + '$'); // Kelvin temperature bounds\n\nvar KELVIN_MIN = 2000;\nvar KELVIN_MAX = 40000; // Math shorthands\n\nvar log = Math.log,\n  round = Math.round,\n  floor = Math.floor;\n/**\r\n * @desc Clamp a number between a min and max value\r\n * @param num - input value\r\n * @param min - min allowed value\r\n * @param max - max allowed value\r\n */\n\nfunction clamp(num, min, max) {\n  return Math.min(Math.max(num, min), max);\n}\n/**\r\n * @desc Parse a css unit string - either regular int or a percentage number\r\n * @param str - css unit string\r\n * @param max - max unit value, used for calculating percentages\r\n */\n\nfunction parseUnit(str, max) {\n  var isPercentage = str.indexOf('%') > -1;\n  var num = parseFloat(str);\n  return isPercentage ? max / 100 * num : num;\n}\n/**\r\n * @desc Parse hex str to an int\r\n * @param str - hex string to parse\r\n */\n\nfunction parseHexInt(str) {\n  return parseInt(str, 16);\n}\n/**\r\n * @desc Convert nunber into to 2-digit hex\r\n * @param int - number to convert\r\n */\n\nfunction intToHex(_int) {\n  return _int.toString(16).padStart(2, '0');\n}\nvar IroColor = /*#__PURE__*/\nfunction () {\n  /**\r\n    * @constructor Color object\r\n    * @param value - initial color value\r\n  */\n  function IroColor(value, onChange) {\n    // The default Color value\n    this.$ = {\n      h: 0,\n      s: 0,\n      v: 0,\n      a: 1\n    };\n    if (value) {\n      this.set(value);\n    } // The watch callback function for this Color will be stored here\n\n    this.onChange = onChange;\n    this.initialValue = _extends({}, this.$); // copy initial value\n  }\n  /**\r\n    * @desc Set the Color from any valid value\r\n    * @param value - new color value\r\n  */\n\n  var _proto = IroColor.prototype;\n  _proto.set = function set(value) {\n    if (typeof value === 'string') {\n      if (/^(?:#?|0x?)[0-9a-fA-F]{3,8}$/.test(value)) {\n        this.hexString = value;\n      } else if (/^rgba?/.test(value)) {\n        this.rgbString = value;\n      } else if (/^hsla?/.test(value)) {\n        this.hslString = value;\n      }\n    } else if (typeof value === 'object') {\n      if (value instanceof IroColor) {\n        this.hsva = value.hsva;\n      } else if ('r' in value && 'g' in value && 'b' in value) {\n        this.rgb = value;\n      } else if ('h' in value && 's' in value && 'v' in value) {\n        this.hsv = value;\n      } else if ('h' in value && 's' in value && 'l' in value) {\n        this.hsl = value;\n      } else if ('kelvin' in value) {\n        this.kelvin = value.kelvin;\n      }\n    } else {\n      throw new Error('Invalid color value');\n    }\n  }\n  /**\r\n    * @desc Shortcut to set a specific channel value\r\n    * @param format - hsv | hsl | rgb\r\n    * @param channel - individual channel to set, for example if model = hsl, chanel = h | s | l\r\n    * @param value - new value for the channel\r\n  */;\n  _proto.setChannel = function setChannel(format, channel, value) {\n    var _extends2;\n    this[format] = _extends({}, this[format], (_extends2 = {}, _extends2[channel] = value, _extends2));\n  }\n  /**\r\n   * @desc Reset color back to its initial value\r\n   */;\n  _proto.reset = function reset() {\n    this.hsva = this.initialValue;\n  }\n  /**\r\n    * @desc make new Color instance with the same value as this one\r\n  */;\n  _proto.clone = function clone() {\n    return new IroColor(this);\n  }\n  /**\r\n   * @desc remove color onChange\r\n   */;\n  _proto.unbind = function unbind() {\n    this.onChange = undefined;\n  }\n  /**\r\n    * @desc Convert hsv object to rgb\r\n    * @param hsv - hsv color object\r\n  */;\n  IroColor.hsvToRgb = function hsvToRgb(hsv) {\n    var h = hsv.h / 60;\n    var s = hsv.s / 100;\n    var v = hsv.v / 100;\n    var i = floor(h);\n    var f = h - i;\n    var p = v * (1 - s);\n    var q = v * (1 - f * s);\n    var t = v * (1 - (1 - f) * s);\n    var mod = i % 6;\n    var r = [v, q, p, p, t, v][mod];\n    var g = [t, v, v, q, p, p][mod];\n    var b = [p, p, t, v, v, q][mod];\n    return {\n      r: clamp(r * 255, 0, 255),\n      g: clamp(g * 255, 0, 255),\n      b: clamp(b * 255, 0, 255)\n    };\n  }\n  /**\r\n    * @desc Convert rgb object to hsv\r\n    * @param rgb - rgb object\r\n  */;\n  IroColor.rgbToHsv = function rgbToHsv(rgb) {\n    var r = rgb.r / 255;\n    var g = rgb.g / 255;\n    var b = rgb.b / 255;\n    var max = Math.max(r, g, b);\n    var min = Math.min(r, g, b);\n    var delta = max - min;\n    var hue = 0;\n    var value = max;\n    var saturation = max === 0 ? 0 : delta / max;\n    switch (max) {\n      case min:\n        hue = 0; // achromatic\n\n        break;\n      case r:\n        hue = (g - b) / delta + (g < b ? 6 : 0);\n        break;\n      case g:\n        hue = (b - r) / delta + 2;\n        break;\n      case b:\n        hue = (r - g) / delta + 4;\n        break;\n    }\n    return {\n      h: hue * 60 % 360,\n      s: clamp(saturation * 100, 0, 100),\n      v: clamp(value * 100, 0, 100)\n    };\n  }\n  /**\r\n    * @desc Convert hsv object to hsl\r\n    * @param hsv - hsv object\r\n  */;\n  IroColor.hsvToHsl = function hsvToHsl(hsv) {\n    var s = hsv.s / 100;\n    var v = hsv.v / 100;\n    var l = (2 - s) * v;\n    var divisor = l <= 1 ? l : 2 - l; // Avoid division by zero when lightness is close to zero\n\n    var saturation = divisor < 1e-9 ? 0 : s * v / divisor;\n    return {\n      h: hsv.h,\n      s: clamp(saturation * 100, 0, 100),\n      l: clamp(l * 50, 0, 100)\n    };\n  }\n  /**\r\n    * @desc Convert hsl object to hsv\r\n    * @param hsl - hsl object\r\n  */;\n  IroColor.hslToHsv = function hslToHsv(hsl) {\n    var l = hsl.l * 2;\n    var s = hsl.s * (l <= 100 ? l : 200 - l) / 100; // Avoid division by zero when l + s is near 0\n\n    var saturation = l + s < 1e-9 ? 0 : 2 * s / (l + s);\n    return {\n      h: hsl.h,\n      s: clamp(saturation * 100, 0, 100),\n      v: clamp((l + s) / 2, 0, 100)\n    };\n  }\n  /**\r\n    * @desc Convert a kelvin temperature to an approx, RGB value\r\n    * @param kelvin - kelvin temperature\r\n  */;\n  IroColor.kelvinToRgb = function kelvinToRgb(kelvin) {\n    var temp = kelvin / 100;\n    var r, g, b;\n    if (temp < 66) {\n      r = 255;\n      g = -155.25485562709179 - 0.44596950469579133 * (g = temp - 2) + 104.49216199393888 * log(g);\n      b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp - 10) + 115.67994401066147 * log(b);\n    } else {\n      r = 351.97690566805693 + 0.114206453784165 * (r = temp - 55) - 40.25366309332127 * log(r);\n      g = 325.4494125711974 + 0.07943456536662342 * (g = temp - 50) - 28.0852963507957 * log(g);\n      b = 255;\n    }\n    return {\n      r: clamp(floor(r), 0, 255),\n      g: clamp(floor(g), 0, 255),\n      b: clamp(floor(b), 0, 255)\n    };\n  }\n  /**\r\n   * @desc Convert an RGB color to an approximate kelvin temperature\r\n   * @param kelvin - kelvin temperature\r\n  */;\n  IroColor.rgbToKelvin = function rgbToKelvin(rgb) {\n    var r = rgb.r,\n      b = rgb.b;\n    var eps = 0.4;\n    var minTemp = KELVIN_MIN;\n    var maxTemp = KELVIN_MAX;\n    var temp;\n    while (maxTemp - minTemp > eps) {\n      temp = (maxTemp + minTemp) * 0.5;\n      var _rgb = IroColor.kelvinToRgb(temp);\n      if (_rgb.b / _rgb.r >= b / r) {\n        maxTemp = temp;\n      } else {\n        minTemp = temp;\n      }\n    }\n    return temp;\n  };\n  _createClass(IroColor, [{\n    key: \"hsv\",\n    get: function get() {\n      // value is cloned to allow changes to be made to the values before passing them back\n      var value = this.$;\n      return {\n        h: value.h,\n        s: value.s,\n        v: value.v\n      };\n    },\n    set: function set(newValue) {\n      var oldValue = this.$;\n      newValue = _extends({}, oldValue, newValue); // If this Color is being watched for changes we need to compare the new and old values to check the difference\n      // Otherwise we can just be lazy\n\n      if (this.onChange) {\n        // Compute changed values\n        var changes = {\n          h: false,\n          v: false,\n          s: false,\n          a: false\n        };\n        for (var key in oldValue) {\n          changes[key] = newValue[key] != oldValue[key];\n        }\n        this.$ = newValue; // If the value has changed, call hook callback\n\n        if (changes.h || changes.s || changes.v || changes.a) {\n          this.onChange(this, changes);\n        }\n      } else {\n        this.$ = newValue;\n      }\n    }\n  }, {\n    key: \"hsva\",\n    get: function get() {\n      return _extends({}, this.$);\n    },\n    set: function set(value) {\n      this.hsv = value;\n    }\n  }, {\n    key: \"hue\",\n    get: function get() {\n      return this.$.h;\n    },\n    set: function set(value) {\n      this.hsv = {\n        h: value\n      };\n    }\n  }, {\n    key: \"saturation\",\n    get: function get() {\n      return this.$.s;\n    },\n    set: function set(value) {\n      this.hsv = {\n        s: value\n      };\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.$.v;\n    },\n    set: function set(value) {\n      this.hsv = {\n        v: value\n      };\n    }\n  }, {\n    key: \"alpha\",\n    get: function get() {\n      return this.$.a;\n    },\n    set: function set(value) {\n      this.hsv = _extends({}, this.hsv, {\n        a: value\n      });\n    }\n  }, {\n    key: \"kelvin\",\n    get: function get() {\n      return IroColor.rgbToKelvin(this.rgb);\n    },\n    set: function set(value) {\n      this.rgb = IroColor.kelvinToRgb(value);\n    }\n  }, {\n    key: \"red\",\n    get: function get() {\n      var rgb = this.rgb;\n      return rgb.r;\n    },\n    set: function set(value) {\n      this.rgb = _extends({}, this.rgb, {\n        r: value\n      });\n    }\n  }, {\n    key: \"green\",\n    get: function get() {\n      var rgb = this.rgb;\n      return rgb.g;\n    },\n    set: function set(value) {\n      this.rgb = _extends({}, this.rgb, {\n        g: value\n      });\n    }\n  }, {\n    key: \"blue\",\n    get: function get() {\n      var rgb = this.rgb;\n      return rgb.b;\n    },\n    set: function set(value) {\n      this.rgb = _extends({}, this.rgb, {\n        b: value\n      });\n    }\n  }, {\n    key: \"rgb\",\n    get: function get() {\n      var _IroColor$hsvToRgb = IroColor.hsvToRgb(this.$),\n        r = _IroColor$hsvToRgb.r,\n        g = _IroColor$hsvToRgb.g,\n        b = _IroColor$hsvToRgb.b;\n      return {\n        r: round(r),\n        g: round(g),\n        b: round(b)\n      };\n    },\n    set: function set(value) {\n      this.hsv = _extends({}, IroColor.rgbToHsv(value), {\n        a: value.a === undefined ? 1 : value.a\n      });\n    }\n  }, {\n    key: \"rgba\",\n    get: function get() {\n      return _extends({}, this.rgb, {\n        a: this.alpha\n      });\n    },\n    set: function set(value) {\n      this.rgb = value;\n    }\n  }, {\n    key: \"hsl\",\n    get: function get() {\n      var _IroColor$hsvToHsl = IroColor.hsvToHsl(this.$),\n        h = _IroColor$hsvToHsl.h,\n        s = _IroColor$hsvToHsl.s,\n        l = _IroColor$hsvToHsl.l;\n      return {\n        h: round(h),\n        s: round(s),\n        l: round(l)\n      };\n    },\n    set: function set(value) {\n      this.hsv = _extends({}, IroColor.hslToHsv(value), {\n        a: value.a === undefined ? 1 : value.a\n      });\n    }\n  }, {\n    key: \"hsla\",\n    get: function get() {\n      return _extends({}, this.hsl, {\n        a: this.alpha\n      });\n    },\n    set: function set(value) {\n      this.hsl = value;\n    }\n  }, {\n    key: \"rgbString\",\n    get: function get() {\n      var rgb = this.rgb;\n      return \"rgb(\" + rgb.r + \", \" + rgb.g + \", \" + rgb.b + \")\";\n    },\n    set: function set(value) {\n      var match;\n      var r,\n        g,\n        b,\n        a = 1;\n      if (match = REGEX_FUNCTIONAL_RGB.exec(value)) {\n        r = parseUnit(match[1], 255);\n        g = parseUnit(match[2], 255);\n        b = parseUnit(match[3], 255);\n      } else if (match = REGEX_FUNCTIONAL_RGBA.exec(value)) {\n        r = parseUnit(match[1], 255);\n        g = parseUnit(match[2], 255);\n        b = parseUnit(match[3], 255);\n        a = parseUnit(match[4], 1);\n      }\n      if (match) {\n        this.rgb = {\n          r: r,\n          g: g,\n          b: b,\n          a: a\n        };\n      } else {\n        throw new Error('Invalid rgb string');\n      }\n    }\n  }, {\n    key: \"rgbaString\",\n    get: function get() {\n      var rgba = this.rgba;\n      return \"rgba(\" + rgba.r + \", \" + rgba.g + \", \" + rgba.b + \", \" + rgba.a + \")\";\n    },\n    set: function set(value) {\n      this.rgbString = value;\n    }\n  }, {\n    key: \"hexString\",\n    get: function get() {\n      var rgb = this.rgb;\n      return \"#\" + intToHex(rgb.r) + intToHex(rgb.g) + intToHex(rgb.b);\n    },\n    set: function set(value) {\n      var match;\n      var r,\n        g,\n        b,\n        a = 255;\n      if (match = REGEX_HEX_3.exec(value)) {\n        r = parseHexInt(match[1]) * 17;\n        g = parseHexInt(match[2]) * 17;\n        b = parseHexInt(match[3]) * 17;\n      } else if (match = REGEX_HEX_4.exec(value)) {\n        r = parseHexInt(match[1]) * 17;\n        g = parseHexInt(match[2]) * 17;\n        b = parseHexInt(match[3]) * 17;\n        a = parseHexInt(match[4]) * 17;\n      } else if (match = REGEX_HEX_6.exec(value)) {\n        r = parseHexInt(match[1]);\n        g = parseHexInt(match[2]);\n        b = parseHexInt(match[3]);\n      } else if (match = REGEX_HEX_8.exec(value)) {\n        r = parseHexInt(match[1]);\n        g = parseHexInt(match[2]);\n        b = parseHexInt(match[3]);\n        a = parseHexInt(match[4]);\n      }\n      if (match) {\n        this.rgb = {\n          r: r,\n          g: g,\n          b: b,\n          a: a / 255\n        };\n      } else {\n        throw new Error('Invalid hex string');\n      }\n    }\n  }, {\n    key: \"hex8String\",\n    get: function get() {\n      var rgba = this.rgba;\n      return \"#\" + intToHex(rgba.r) + intToHex(rgba.g) + intToHex(rgba.b) + intToHex(floor(rgba.a * 255));\n    },\n    set: function set(value) {\n      this.hexString = value;\n    }\n  }, {\n    key: \"hslString\",\n    get: function get() {\n      var hsl = this.hsl;\n      return \"hsl(\" + hsl.h + \", \" + hsl.s + \"%, \" + hsl.l + \"%)\";\n    },\n    set: function set(value) {\n      var match;\n      var h,\n        s,\n        l,\n        a = 1;\n      if (match = REGEX_FUNCTIONAL_HSL.exec(value)) {\n        h = parseUnit(match[1], 360);\n        s = parseUnit(match[2], 100);\n        l = parseUnit(match[3], 100);\n      } else if (match = REGEX_FUNCTIONAL_HSLA.exec(value)) {\n        h = parseUnit(match[1], 360);\n        s = parseUnit(match[2], 100);\n        l = parseUnit(match[3], 100);\n        a = parseUnit(match[4], 1);\n      }\n      if (match) {\n        this.hsl = {\n          h: h,\n          s: s,\n          l: l,\n          a: a\n        };\n      } else {\n        throw new Error('Invalid hsl string');\n      }\n    }\n  }, {\n    key: \"hslaString\",\n    get: function get() {\n      var hsla = this.hsla;\n      return \"hsla(\" + hsla.h + \", \" + hsla.s + \"%, \" + hsla.l + \"%, \" + hsla.a + \")\";\n    },\n    set: function set(value) {\n      this.hslString = value;\n    }\n  }]);\n  return IroColor;\n}();\nvar sliderDefaultOptions = {\n  sliderShape: 'bar',\n  sliderType: 'value',\n  minTemperature: 2200,\n  maxTemperature: 11000\n};\n/**\r\n * @desc Get the bounding dimensions of the slider\r\n * @param props - slider props\r\n */\n\nfunction getSliderDimensions(props) {\n  var _sliderSize;\n  var width = props.width,\n    sliderSize = props.sliderSize,\n    borderWidth = props.borderWidth,\n    handleRadius = props.handleRadius,\n    padding = props.padding,\n    sliderShape = props.sliderShape;\n  var ishorizontal = props.layoutDirection === 'horizontal'; // automatically calculate sliderSize if its not defined\n\n  sliderSize = (_sliderSize = sliderSize) != null ? _sliderSize : padding * 2 + handleRadius * 2;\n  if (sliderShape === 'circle') {\n    return {\n      handleStart: props.padding + props.handleRadius,\n      handleRange: width - padding * 2 - handleRadius * 2,\n      width: width,\n      height: width,\n      cx: width / 2,\n      cy: width / 2,\n      radius: width / 2 - borderWidth / 2\n    };\n  } else {\n    return {\n      handleStart: sliderSize / 2,\n      handleRange: width - sliderSize,\n      radius: sliderSize / 2,\n      x: 0,\n      y: 0,\n      width: ishorizontal ? sliderSize : width,\n      height: ishorizontal ? width : sliderSize\n    };\n  }\n}\n/**\r\n * @desc Get the current slider value for a given color, as a percentage\r\n * @param props - slider props\r\n * @param color\r\n */\n\nfunction getCurrentSliderValue(props, color) {\n  var hsva = color.hsva;\n  var rgb = color.rgb;\n  switch (props.sliderType) {\n    case 'red':\n      return rgb.r / 2.55;\n    case 'green':\n      return rgb.g / 2.55;\n    case 'blue':\n      return rgb.b / 2.55;\n    case 'alpha':\n      return hsva.a * 100;\n    case 'kelvin':\n      var minTemperature = props.minTemperature,\n        maxTemperature = props.maxTemperature;\n      var temperatureRange = maxTemperature - minTemperature;\n      var percent = (color.kelvin - minTemperature) / temperatureRange * 100; // clmap percentage\n\n      return Math.max(0, Math.min(percent, 100));\n    case 'hue':\n      return hsva.h /= 3.6;\n    case 'saturation':\n      return hsva.s;\n    case 'value':\n    default:\n      return hsva.v;\n  }\n}\n/**\r\n * @desc Get the current slider value from user input\r\n * @param props - slider props\r\n * @param x - global input x position\r\n * @param y - global input y position\r\n */\n\nfunction getSliderValueFromInput(props, x, y) {\n  var _getSliderDimensions = getSliderDimensions(props),\n    handleRange = _getSliderDimensions.handleRange,\n    handleStart = _getSliderDimensions.handleStart;\n  var handlePos;\n  if (props.layoutDirection === 'horizontal') {\n    handlePos = -1 * y + handleRange + handleStart;\n  } else {\n    handlePos = x - handleStart;\n  } // clamp handle position\n\n  handlePos = Math.max(Math.min(handlePos, handleRange), 0);\n  var percent = Math.round(100 / handleRange * handlePos);\n  switch (props.sliderType) {\n    case 'kelvin':\n      var minTemperature = props.minTemperature,\n        maxTemperature = props.maxTemperature;\n      var temperatureRange = maxTemperature - minTemperature;\n      return minTemperature + temperatureRange * (percent / 100);\n    case 'alpha':\n      return percent / 100;\n    case 'hue':\n      return percent * 3.6;\n    case 'red':\n    case 'blue':\n    case 'green':\n      return percent * 2.55;\n    default:\n      return percent;\n  }\n}\n/**\r\n * @desc Get the current handle position for a given color\r\n * @param props - slider props\r\n * @param color\r\n */\n\nfunction getSliderHandlePosition(props, color) {\n  var _getSliderDimensions2 = getSliderDimensions(props),\n    width = _getSliderDimensions2.width,\n    height = _getSliderDimensions2.height,\n    handleRange = _getSliderDimensions2.handleRange,\n    handleStart = _getSliderDimensions2.handleStart;\n  var ishorizontal = props.layoutDirection === 'horizontal';\n  var sliderValue = getCurrentSliderValue(props, color);\n  var midPoint = ishorizontal ? width / 2 : height / 2;\n  var handlePos = handleStart + sliderValue / 100 * handleRange;\n  if (ishorizontal) {\n    handlePos = -1 * handlePos + handleRange + handleStart * 2;\n  }\n  return {\n    x: ishorizontal ? midPoint : handlePos,\n    y: ishorizontal ? handlePos : midPoint\n  };\n}\n/**\r\n * @desc Get the gradient stops for a slider\r\n * @param props - slider props\r\n * @param color\r\n */\n\nfunction getSliderGradient(props, color) {\n  var hsv = color.hsv;\n  var rgb = color.rgb;\n  switch (props.sliderType) {\n    case 'red':\n      return [[0, \"rgb(\" + 0 + \",\" + rgb.g + \",\" + rgb.b + \")\"], [100, \"rgb(\" + 255 + \",\" + rgb.g + \",\" + rgb.b + \")\"]];\n    case 'green':\n      return [[0, \"rgb(\" + rgb.r + \",\" + 0 + \",\" + rgb.b + \")\"], [100, \"rgb(\" + rgb.r + \",\" + 255 + \",\" + rgb.b + \")\"]];\n    case 'blue':\n      return [[0, \"rgb(\" + rgb.r + \",\" + rgb.g + \",\" + 0 + \")\"], [100, \"rgb(\" + rgb.r + \",\" + rgb.g + \",\" + 255 + \")\"]];\n    case 'alpha':\n      return [[0, \"rgba(\" + rgb.r + \",\" + rgb.g + \",\" + rgb.b + \",0)\"], [100, \"rgb(\" + rgb.r + \",\" + rgb.g + \",\" + rgb.b + \")\"]];\n    case 'kelvin':\n      var stops = [];\n      var min = props.minTemperature;\n      var max = props.maxTemperature;\n      var numStops = 8;\n      var range = max - min;\n      for (var kelvin = min, stop = 0; kelvin < max; kelvin += range / numStops, stop += 1) {\n        var _IroColor$kelvinToRgb = IroColor.kelvinToRgb(kelvin),\n          r = _IroColor$kelvinToRgb.r,\n          g = _IroColor$kelvinToRgb.g,\n          b = _IroColor$kelvinToRgb.b;\n        stops.push([100 / numStops * stop, \"rgb(\" + r + \",\" + g + \",\" + b + \")\"]);\n      }\n      return stops;\n    case 'hue':\n      return [[0, '#f00'], [16.666, '#ff0'], [33.333, '#0f0'], [50, '#0ff'], [66.666, '#00f'], [83.333, '#f0f'], [100, '#f00']];\n    case 'saturation':\n      var noSat = IroColor.hsvToHsl({\n        h: hsv.h,\n        s: 0,\n        v: hsv.v\n      });\n      var fullSat = IroColor.hsvToHsl({\n        h: hsv.h,\n        s: 100,\n        v: hsv.v\n      });\n      return [[0, \"hsl(\" + noSat.h + \",\" + noSat.s + \"%,\" + noSat.l + \"%)\"], [100, \"hsl(\" + fullSat.h + \",\" + fullSat.s + \"%,\" + fullSat.l + \"%)\"]];\n    case 'value':\n    default:\n      var hsl = IroColor.hsvToHsl({\n        h: hsv.h,\n        s: hsv.s,\n        v: 100\n      });\n      return [[0, '#000'], [100, \"hsl(\" + hsl.h + \",\" + hsl.s + \"%,\" + hsl.l + \"%)\"]];\n  }\n}\nvar TAU = Math.PI * 2; // javascript's modulo operator doesn't produce positive numbers with negative input\n// https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e\n\nvar mod = function mod(a, n) {\n  return (a % n + n) % n;\n}; // distance between points (x, y) and (0, 0)\n\nvar dist = function dist(x, y) {\n  return Math.sqrt(x * x + y * y);\n};\n/**\r\n * @param props - wheel props\r\n * @internal\r\n */\n\nfunction getHandleRange(props) {\n  return props.width / 2 - props.padding - props.handleRadius - props.borderWidth;\n}\n/**\r\n * Returns true if point (x, y) lands inside the wheel\r\n * @param props - wheel props\r\n * @param x\r\n * @param y\r\n */\n\nfunction isInputInsideWheel(props, x, y) {\n  var _getWheelDimensions = getWheelDimensions(props),\n    cx = _getWheelDimensions.cx,\n    cy = _getWheelDimensions.cy;\n  var r = props.width / 2;\n  return dist(cx - x, cy - y) < r;\n}\n/**\r\n * @desc Get the point as the center of the wheel\r\n * @param props - wheel props\r\n */\n\nfunction getWheelDimensions(props) {\n  var r = props.width / 2;\n  return {\n    width: props.width,\n    radius: r - props.borderWidth,\n    cx: r,\n    cy: r\n  };\n}\n/**\r\n * @desc Translate an angle according to wheelAngle and wheelDirection\r\n * @param props - wheel props\r\n * @param angle - input angle\r\n */\n\nfunction translateWheelAngle(props, angle, invert) {\n  var wheelAngle = props.wheelAngle;\n  var wheelDirection = props.wheelDirection; // inverted and clockwisee\n\n  if (invert && wheelDirection === 'clockwise') {\n    angle = wheelAngle + angle;\n  } // clockwise (input handling)\n  else if (wheelDirection === 'clockwise') {\n    angle = 360 - wheelAngle + angle;\n  } // inverted and anticlockwise\n  else if (invert && wheelDirection === 'anticlockwise') {\n    angle = wheelAngle + 180 - angle;\n  } // anticlockwise (input handling)\n  else if (wheelDirection === 'anticlockwise') {\n    angle = wheelAngle - angle;\n  }\n  return mod(angle, 360);\n}\n/**\r\n * @desc Get the current handle position for a given color\r\n * @param props - wheel props\r\n * @param color\r\n */\n\nfunction getWheelHandlePosition(props, color) {\n  var hsv = color.hsv;\n  var _getWheelDimensions2 = getWheelDimensions(props),\n    cx = _getWheelDimensions2.cx,\n    cy = _getWheelDimensions2.cy;\n  var handleRange = getHandleRange(props);\n  var handleAngle = (180 + translateWheelAngle(props, hsv.h, true)) * (TAU / 360);\n  var handleDist = hsv.s / 100 * handleRange;\n  var direction = props.wheelDirection === 'clockwise' ? -1 : 1;\n  return {\n    x: cx + handleDist * Math.cos(handleAngle) * direction,\n    y: cy + handleDist * Math.sin(handleAngle) * direction\n  };\n}\n/**\r\n * @desc Get the current wheel value from user input\r\n * @param props - wheel props\r\n * @param x - global input x position\r\n * @param y - global input y position\r\n */\n\nfunction getWheelValueFromInput(props, x, y) {\n  var _getWheelDimensions3 = getWheelDimensions(props),\n    cx = _getWheelDimensions3.cx,\n    cy = _getWheelDimensions3.cy;\n  var handleRange = getHandleRange(props);\n  x = cx - x;\n  y = cy - y; // Calculate the hue by converting the angle to radians\n\n  var hue = translateWheelAngle(props, Math.atan2(-y, -x) * (360 / TAU)); // Find the point's distance from the center of the wheel\n  // This is used to show the saturation level\n\n  var handleDist = Math.min(dist(x, y), handleRange);\n  return {\n    h: Math.round(hue),\n    s: Math.round(100 / handleRange * handleDist)\n  };\n}\n/**\r\n * @desc Get the bounding dimensions of the box\r\n * @param props - box props\r\n */\n\nfunction getBoxDimensions(props) {\n  var width = props.width,\n    boxHeight = props.boxHeight,\n    padding = props.padding,\n    handleRadius = props.handleRadius;\n  return {\n    width: width,\n    height: boxHeight != null ? boxHeight : width,\n    radius: padding + handleRadius\n  };\n}\n/**\r\n * @desc Get the current box value from user input\r\n * @param props - box props\r\n * @param x - global input x position\r\n * @param y - global input y position\r\n */\n\nfunction getBoxValueFromInput(props, x, y) {\n  var _getBoxDimensions = getBoxDimensions(props),\n    width = _getBoxDimensions.width,\n    height = _getBoxDimensions.height,\n    radius = _getBoxDimensions.radius;\n  var handleStart = radius;\n  var handleRangeX = width - radius * 2;\n  var handleRangeY = height - radius * 2;\n  var percentX = (x - handleStart) / handleRangeX * 100;\n  var percentY = (y - handleStart) / handleRangeY * 100;\n  return {\n    s: Math.max(0, Math.min(percentX, 100)),\n    v: Math.max(0, Math.min(100 - percentY, 100))\n  };\n}\n/**\r\n * @desc Get the current box handle position for a given color\r\n * @param props - box props\r\n * @param color\r\n */\n\nfunction getBoxHandlePosition(props, color) {\n  var _getBoxDimensions2 = getBoxDimensions(props),\n    width = _getBoxDimensions2.width,\n    height = _getBoxDimensions2.height,\n    radius = _getBoxDimensions2.radius;\n  var hsv = color.hsv;\n  var handleStart = radius;\n  var handleRangeX = width - radius * 2;\n  var handleRangeY = height - radius * 2;\n  return {\n    x: handleStart + hsv.s / 100 * handleRangeX,\n    y: handleStart + (handleRangeY - hsv.v / 100 * handleRangeY)\n  };\n}\n/**\r\n * @desc Get the gradient stops for a box\r\n * @param props - box props\r\n * @param color\r\n */\n\nfunction getBoxGradients(props, color) {\n  var hue = color.hue;\n  return [\n  // saturation gradient\n  [[0, '#fff'], [100, \"hsl(\" + hue + \",100%,50%)\"]],\n  // lightness gradient\n  [[0, 'rgba(0,0,0,0)'], [100, '#000']]];\n}\n\n// Keep track of html <base> elements for resolveSvgUrl\n// getElementsByTagName returns a live HTMLCollection, which stays in sync with the DOM tree\n// So it only needs to be called once\nvar BASE_ELEMENTS;\n/**\r\n * @desc Resolve an SVG reference URL\r\n * This is required to work around how Safari and iOS webviews handle gradient URLS under certain conditions\r\n * If a page is using a client-side routing library which makes use of the HTML <base> tag,\r\n * Safari won't be able to render SVG gradients properly (as they are referenced by URLs)\r\n * More info on the problem:\r\n * https://stackoverflow.com/questions/19742805/angular-and-svg-filters/19753427#19753427\r\n * https://github.com/jaames/iro.js/issues/18\r\n * https://github.com/jaames/iro.js/issues/45\r\n * https://github.com/jaames/iro.js/pull/89\r\n * @props url - SVG reference URL\r\n */\n\nfunction resolveSvgUrl(url) {\n  if (!BASE_ELEMENTS) {\n    BASE_ELEMENTS = document.getElementsByTagName('base');\n  } // Sniff useragent string to check if the user is running Safari\n\n  var ua = window.navigator.userAgent;\n  var isSafari = /^((?!chrome|android).)*safari/i.test(ua);\n  var isIos = /iPhone|iPod|iPad/i.test(ua);\n  var location = window.location;\n  return (isSafari || isIos) && BASE_ELEMENTS.length > 0 ? location.protocol + \"//\" + location.host + location.pathname + location.search + url : url;\n}\n/**\r\n * @desc Given a specifc (x, y) position, test if there's a handle there and return its index, else return null.\r\n *       This is used for components like the box and wheel which support multiple handles when multicolor is active\r\n * @props x - point x position\r\n * @props y - point y position\r\n * @props handlePositions - array of {x, y} coords for each handle\r\n */\n\nfunction getHandleAtPoint(props, x, y, handlePositions) {\n  for (var i = 0; i < handlePositions.length; i++) {\n    var dX = handlePositions[i].x - x;\n    var dY = handlePositions[i].y - y;\n    var dist = Math.sqrt(dX * dX + dY * dY);\n    if (dist < props.handleRadius) {\n      return i;\n    }\n  }\n  return null;\n}\nfunction cssBorderStyles(props) {\n  return {\n    boxSizing: 'border-box',\n    border: props.borderWidth + \"px solid \" + props.borderColor\n  };\n}\nfunction cssGradient(type, direction, stops) {\n  return type + \"-gradient(\" + direction + \", \" + stops.map(function (_ref) {\n    var o = _ref[0],\n      col = _ref[1];\n    return col + \" \" + o + \"%\";\n  }).join(',') + \")\";\n}\nfunction cssValue(value) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  return value + \"px\";\n}\nvar iroColorPickerOptionDefaults = {\n  width: 300,\n  height: 300,\n  color: '#fff',\n  colors: [],\n  padding: 6,\n  layoutDirection: 'vertical',\n  borderColor: '#fff',\n  borderWidth: 0,\n  handleRadius: 8,\n  activeHandleRadius: null,\n  handleSvg: null,\n  handleProps: {\n    x: 0,\n    y: 0\n  },\n  wheelLightness: true,\n  wheelAngle: 0,\n  wheelDirection: 'anticlockwise',\n  sliderSize: null,\n  sliderMargin: 12,\n  boxHeight: null\n};\nvar SECONDARY_EVENTS = [\"mousemove\" /* MouseMove */, \"touchmove\" /* TouchMove */, \"mouseup\" /* MouseUp */, \"touchend\" /* TouchEnd */];\n// Base component class for iro UI components\n// This extends the Preact component class to allow them to react to mouse/touch input events by themselves\nvar IroComponentWrapper = /*@__PURE__*/function (Component) {\n  function IroComponentWrapper(props) {\n    Component.call(this, props);\n    // Generate unique ID for the component\n    // This can be used to generate unique IDs for gradients, etc\n    this.uid = (Math.random() + 1).toString(36).substring(5);\n  }\n  if (Component) IroComponentWrapper.__proto__ = Component;\n  IroComponentWrapper.prototype = Object.create(Component && Component.prototype);\n  IroComponentWrapper.prototype.constructor = IroComponentWrapper;\n  IroComponentWrapper.prototype.render = function render(props) {\n    var eventHandler = this.handleEvent.bind(this);\n    var rootProps = {\n      onMouseDown: eventHandler,\n      // https://github.com/jaames/iro.js/issues/126\n      // https://github.com/preactjs/preact/issues/2113#issuecomment-553408767\n      ontouchstart: eventHandler\n    };\n    var isHorizontal = props.layoutDirection === 'horizontal';\n    var margin = props.margin === null ? props.sliderMargin : props.margin;\n    var rootStyles = {\n      overflow: 'visible',\n      display: isHorizontal ? 'inline-block' : 'block'\n    };\n    // first component shouldn't have any margin\n    if (props.index > 0) {\n      rootStyles[isHorizontal ? 'marginLeft' : 'marginTop'] = margin;\n    }\n    return h(d, null, props.children(this.uid, rootProps, rootStyles));\n  };\n  // More info on handleEvent:\n  // https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\n  // TL;DR this lets us have a single point of entry for multiple events, and we can avoid callback/binding hell\n  IroComponentWrapper.prototype.handleEvent = function handleEvent(e) {\n    var this$1 = this;\n    var inputHandler = this.props.onInput;\n    // Get the screen position of the component\n    var bounds = this.base.getBoundingClientRect();\n    // Prefect default browser action\n    e.preventDefault();\n    // Detect if the event is a touch event by checking if it has the `touches` property\n    // If it is a touch event, use the first touch input\n    var point = e.touches ? e.changedTouches[0] : e;\n    var x = point.clientX - bounds.left;\n    var y = point.clientY - bounds.top;\n    switch (e.type) {\n      case \"mousedown\" /* MouseDown */:\n      case \"touchstart\" /* TouchStart */:\n        var result = inputHandler(x, y, 0 /* Start */);\n        if (result !== false) {\n          SECONDARY_EVENTS.forEach(function (event) {\n            document.addEventListener(event, this$1, {\n              passive: false\n            });\n          });\n        }\n        break;\n      case \"mousemove\" /* MouseMove */:\n      case \"touchmove\" /* TouchMove */:\n        inputHandler(x, y, 1 /* Move */);\n        break;\n      case \"mouseup\" /* MouseUp */:\n      case \"touchend\" /* TouchEnd */:\n        inputHandler(x, y, 2 /* End */);\n        SECONDARY_EVENTS.forEach(function (event) {\n          document.removeEventListener(event, this$1, {\n            passive: false\n          });\n        });\n        break;\n    }\n  };\n  return IroComponentWrapper;\n}(m);\nfunction IroHandle(props) {\n  var radius = props.r;\n  var url = props.url;\n  var cx = radius;\n  var cy = radius;\n  return h(\"svg\", {\n    className: \"IroHandle IroHandle--\" + props.index + \" \" + (props.isActive ? 'IroHandle--isActive' : ''),\n    style: {\n      '-webkit-tap-highlight-color': 'rgba(0, 0, 0, 0);',\n      transform: \"translate(\" + cssValue(props.x) + \", \" + cssValue(props.y) + \")\",\n      willChange: 'transform',\n      top: cssValue(-radius),\n      left: cssValue(-radius),\n      width: cssValue(radius * 2),\n      height: cssValue(radius * 2),\n      position: 'absolute',\n      overflow: 'visible'\n    }\n  }, url && h(\"use\", Object.assign({\n    xlinkHref: resolveSvgUrl(url)\n  }, props.props)), !url && h(\"circle\", {\n    cx: cx,\n    cy: cy,\n    r: radius,\n    fill: \"none\",\n    \"stroke-width\": 2,\n    stroke: \"#000\"\n  }), !url && h(\"circle\", {\n    cx: cx,\n    cy: cy,\n    r: radius - 2,\n    fill: props.fill,\n    \"stroke-width\": 2,\n    stroke: \"#fff\"\n  }));\n}\nIroHandle.defaultProps = {\n  fill: 'none',\n  x: 0,\n  y: 0,\n  r: 8,\n  url: null,\n  props: {\n    x: 0,\n    y: 0\n  }\n};\nfunction IroSlider(props) {\n  var activeIndex = props.activeIndex;\n  var activeColor = activeIndex !== undefined && activeIndex < props.colors.length ? props.colors[activeIndex] : props.color;\n  var ref = getSliderDimensions(props);\n  var width = ref.width;\n  var height = ref.height;\n  var radius = ref.radius;\n  var handlePos = getSliderHandlePosition(props, activeColor);\n  var gradient = getSliderGradient(props, activeColor);\n  function handleInput(x, y, type) {\n    var value = getSliderValueFromInput(props, x, y);\n    props.parent.inputActive = true;\n    activeColor[props.sliderType] = value;\n    props.onInput(type, props.id);\n  }\n  return h(IroComponentWrapper, Object.assign({}, props, {\n    onInput: handleInput\n  }), function (uid, rootProps, rootStyles) {\n    return h(\"div\", Object.assign({}, rootProps, {\n      className: \"IroSlider\",\n      style: Object.assign({}, {\n        position: 'relative',\n        width: cssValue(width),\n        height: cssValue(height),\n        borderRadius: cssValue(radius),\n        // checkered bg to represent alpha\n        background: \"conic-gradient(#ccc 25%, #fff 0 50%, #ccc 0 75%, #fff 0)\",\n        backgroundSize: '8px 8px'\n      }, rootStyles)\n    }), h(\"div\", {\n      className: \"IroSliderGradient\",\n      style: Object.assign({}, {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: \"100%\",\n        height: \"100%\",\n        borderRadius: cssValue(radius),\n        background: cssGradient('linear', props.layoutDirection === 'horizontal' ? 'to top' : 'to right', gradient)\n      }, cssBorderStyles(props))\n    }), h(IroHandle, {\n      isActive: true,\n      index: activeColor.index,\n      r: props.handleRadius,\n      url: props.handleSvg,\n      props: props.handleProps,\n      x: handlePos.x,\n      y: handlePos.y\n    }));\n  });\n}\nIroSlider.defaultProps = Object.assign({}, sliderDefaultOptions);\nfunction IroBox(props) {\n  var ref = getBoxDimensions(props);\n  var width = ref.width;\n  var height = ref.height;\n  var radius = ref.radius;\n  var colors = props.colors;\n  var colorPicker = props.parent;\n  var activeIndex = props.activeIndex;\n  var activeColor = activeIndex !== undefined && activeIndex < props.colors.length ? props.colors[activeIndex] : props.color;\n  var gradients = getBoxGradients(props, activeColor);\n  var handlePositions = colors.map(function (color) {\n    return getBoxHandlePosition(props, color);\n  });\n  function handleInput(x, y, inputType) {\n    if (inputType === 0 /* Start */) {\n      // getHandleAtPoint() returns the index for the handle if the point 'hits' it, or null otherwise\n      var activeHandle = getHandleAtPoint(props, x, y, handlePositions);\n      // If the input hit a handle, set it as the active handle, but don't update the color\n      if (activeHandle !== null) {\n        colorPicker.setActiveColor(activeHandle);\n      }\n      // If the input didn't hit a handle, set the currently active handle to that position\n      else {\n        colorPicker.inputActive = true;\n        activeColor.hsv = getBoxValueFromInput(props, x, y);\n        props.onInput(inputType, props.id);\n      }\n    }\n    // move is fired when the user has started dragging\n    else if (inputType === 1 /* Move */) {\n      colorPicker.inputActive = true;\n      activeColor.hsv = getBoxValueFromInput(props, x, y);\n    }\n    // let the color picker fire input:start, input:move or input:end events\n    props.onInput(inputType, props.id);\n  }\n  return h(IroComponentWrapper, Object.assign({}, props, {\n    onInput: handleInput\n  }), function (uid, rootProps, rootStyles) {\n    return h(\"div\", Object.assign({}, rootProps, {\n      className: \"IroBox\",\n      style: Object.assign({}, {\n        width: cssValue(width),\n        height: cssValue(height),\n        position: 'relative'\n      }, rootStyles)\n    }), h(\"div\", {\n      className: \"IroBox\",\n      style: Object.assign({}, {\n        width: '100%',\n        height: '100%',\n        borderRadius: cssValue(radius)\n      }, cssBorderStyles(props), {\n        background: cssGradient('linear', 'to bottom', gradients[1]) + ',' + cssGradient('linear', 'to right', gradients[0])\n      })\n    }), colors.filter(function (color) {\n      return color !== activeColor;\n    }).map(function (color) {\n      return h(IroHandle, {\n        isActive: false,\n        index: color.index,\n        fill: color.hslString,\n        r: props.handleRadius,\n        url: props.handleSvg,\n        props: props.handleProps,\n        x: handlePositions[color.index].x,\n        y: handlePositions[color.index].y\n      });\n    }), h(IroHandle, {\n      isActive: true,\n      index: activeColor.index,\n      fill: activeColor.hslString,\n      r: props.activeHandleRadius || props.handleRadius,\n      url: props.handleSvg,\n      props: props.handleProps,\n      x: handlePositions[activeColor.index].x,\n      y: handlePositions[activeColor.index].y\n    }));\n  });\n}\nvar HUE_GRADIENT_CLOCKWISE = 'conic-gradient(red, yellow, lime, aqua, blue, magenta, red)';\nvar HUE_GRADIENT_ANTICLOCKWISE = 'conic-gradient(red, magenta, blue, aqua, lime, yellow, red)';\nfunction IroWheel(props) {\n  var ref = getWheelDimensions(props);\n  var width = ref.width;\n  var colors = props.colors;\n  var borderWidth = props.borderWidth;\n  var colorPicker = props.parent;\n  var activeColor = props.color;\n  var hsv = activeColor.hsv;\n  var handlePositions = colors.map(function (color) {\n    return getWheelHandlePosition(props, color);\n  });\n  var circleStyles = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    borderRadius: '50%',\n    boxSizing: 'border-box'\n  };\n  function handleInput(x, y, inputType) {\n    if (inputType === 0 /* Start */) {\n      // input hitbox is a square, \n      // so we want to ignore any initial clicks outside the circular shape of the wheel\n      if (!isInputInsideWheel(props, x, y)) {\n        // returning false will cease all event handling for this interaction\n        return false;\n      }\n      // getHandleAtPoint() returns the index for the handle if the point 'hits' it, or null otherwise\n      var activeHandle = getHandleAtPoint(props, x, y, handlePositions);\n      // If the input hit a handle, set it as the active handle, but don't update the color\n      if (activeHandle !== null) {\n        colorPicker.setActiveColor(activeHandle);\n      }\n      // If the input didn't hit a handle, set the currently active handle to that position\n      else {\n        colorPicker.inputActive = true;\n        activeColor.hsv = getWheelValueFromInput(props, x, y);\n        props.onInput(inputType, props.id);\n      }\n    }\n    // move is fired when the user has started dragging\n    else if (inputType === 1 /* Move */) {\n      colorPicker.inputActive = true;\n      activeColor.hsv = getWheelValueFromInput(props, x, y);\n    }\n    // let the color picker fire input:start, input:move or input:end events\n    props.onInput(inputType, props.id);\n  }\n  return h(IroComponentWrapper, Object.assign({}, props, {\n    onInput: handleInput\n  }), function (uid, rootProps, rootStyles) {\n    return h(\"div\", Object.assign({}, rootProps, {\n      className: \"IroWheel\",\n      style: Object.assign({}, {\n        width: cssValue(width),\n        height: cssValue(width),\n        position: 'relative'\n      }, rootStyles)\n    }), h(\"div\", {\n      className: \"IroWheelHue\",\n      style: Object.assign({}, circleStyles, {\n        transform: \"rotateZ(\" + (props.wheelAngle + 90) + \"deg)\",\n        background: props.wheelDirection === 'clockwise' ? HUE_GRADIENT_CLOCKWISE : HUE_GRADIENT_ANTICLOCKWISE\n      })\n    }), h(\"div\", {\n      className: \"IroWheelSaturation\",\n      style: Object.assign({}, circleStyles, {\n        background: 'radial-gradient(circle closest-side, #fff, transparent)'\n      })\n    }), props.wheelLightness && h(\"div\", {\n      className: \"IroWheelLightness\",\n      style: Object.assign({}, circleStyles, {\n        background: '#000',\n        opacity: 1 - hsv.v / 100\n      })\n    }), h(\"div\", {\n      className: \"IroWheelBorder\",\n      style: Object.assign({}, circleStyles, cssBorderStyles(props))\n    }), colors.filter(function (color) {\n      return color !== activeColor;\n    }).map(function (color) {\n      return h(IroHandle, {\n        isActive: false,\n        index: color.index,\n        fill: color.hslString,\n        r: props.handleRadius,\n        url: props.handleSvg,\n        props: props.handleProps,\n        x: handlePositions[color.index].x,\n        y: handlePositions[color.index].y\n      });\n    }), h(IroHandle, {\n      isActive: true,\n      index: activeColor.index,\n      fill: activeColor.hslString,\n      r: props.activeHandleRadius || props.handleRadius,\n      url: props.handleSvg,\n      props: props.handleProps,\n      x: handlePositions[activeColor.index].x,\n      y: handlePositions[activeColor.index].y\n    }));\n  });\n}\nfunction createWidget(WidgetComponent) {\n  var widgetFactory = function (parent, props) {\n    var widget; // will become an instance of the widget component class\n    var widgetRoot = document.createElement('div');\n    // Render widget into a temp DOM node\n    I(h(WidgetComponent, Object.assign({}, {\n      ref: function (ref) {\n        return widget = ref;\n      }\n    }, props)), widgetRoot);\n    function mountWidget() {\n      var container = parent instanceof Element ? parent : document.querySelector(parent);\n      container.appendChild(widget.base);\n      widget.onMount(container);\n    }\n    // Mount it into the DOM when the page document is ready\n    if (document.readyState !== 'loading') {\n      mountWidget();\n    } else {\n      document.addEventListener('DOMContentLoaded', mountWidget);\n    }\n    return widget;\n  };\n  // Allow the widget factory to inherit component prototype + static class methods\n  // This makes it easier for plugin authors to extend the base widget component\n  widgetFactory.prototype = WidgetComponent.prototype;\n  Object.assign(widgetFactory, WidgetComponent);\n  // Add reference to base component too\n  widgetFactory.__component = WidgetComponent;\n  return widgetFactory;\n}\nvar IroColorPicker = /*@__PURE__*/function (Component) {\n  function IroColorPicker(props) {\n    var this$1 = this;\n    Component.call(this, props);\n    this.colors = [];\n    this.inputActive = false;\n    this.events = {};\n    this.activeEvents = {};\n    this.deferredEvents = {};\n    this.id = props.id;\n    var colors = props.colors.length > 0 ? props.colors : [props.color];\n    colors.forEach(function (colorValue) {\n      return this$1.addColor(colorValue);\n    });\n    this.setActiveColor(0);\n    // Pass all the props into the component's state,\n    // Except we want to add the color object and make sure that refs aren't passed down to children\n    this.state = Object.assign({}, props, {\n      color: this.color,\n      colors: this.colors,\n      layout: props.layout\n    });\n  }\n  if (Component) IroColorPicker.__proto__ = Component;\n  IroColorPicker.prototype = Object.create(Component && Component.prototype);\n  IroColorPicker.prototype.constructor = IroColorPicker;\n  // Plubic multicolor API\n  /**\r\n  * @desc Add a color to the color picker\r\n  * @param color new color to add\r\n  * @param index optional color index\r\n  */\n  IroColorPicker.prototype.addColor = function addColor(color, index) {\n    if (index === void 0) index = this.colors.length;\n\n    // Create a new iro.Color\n    // Also bind it to onColorChange, so whenever the color changes it updates the color picker\n    var newColor = new IroColor(color, this.onColorChange.bind(this));\n    // Insert color @ the given index\n    this.colors.splice(index, 0, newColor);\n    // Reindex colors\n    this.colors.forEach(function (color, index) {\n      return color.index = index;\n    });\n    // Update picker state if necessary\n    if (this.state) {\n      this.setState({\n        colors: this.colors\n      });\n    }\n    // Fire color init event\n    this.deferredEmit('color:init', newColor);\n  };\n  /**\r\n   * @desc Remove a color from the color picker\r\n   * @param index color index\r\n   */\n  IroColorPicker.prototype.removeColor = function removeColor(index) {\n    var color = this.colors.splice(index, 1)[0];\n    // Destroy the color object -- this unbinds it from the color picker\n    color.unbind();\n    // Reindex colors\n    this.colors.forEach(function (color, index) {\n      return color.index = index;\n    });\n    // Update picker state if necessary\n    if (this.state) {\n      this.setState({\n        colors: this.colors\n      });\n    }\n    // If the active color was removed, default active color to 0\n    if (color.index === this.color.index) {\n      this.setActiveColor(0);\n    }\n    // Fire color remove event\n    this.emit('color:remove', color);\n  };\n  /**\r\n   * @desc Set the currently active color\r\n   * @param index color index\r\n   */\n  IroColorPicker.prototype.setActiveColor = function setActiveColor(index) {\n    this.color = this.colors[index];\n    if (this.state) {\n      this.setState({\n        color: this.color\n      });\n    }\n    // Fire color switch event\n    this.emit('color:setActive', this.color);\n  };\n  /**\r\n   * @desc Replace all of the current colorPicker colors\r\n   * @param newColorValues list of new colors to add\r\n   */\n  IroColorPicker.prototype.setColors = function setColors(newColorValues, activeColorIndex) {\n    var this$1 = this;\n    if (activeColorIndex === void 0) activeColorIndex = 0;\n\n    // Unbind color events\n    this.colors.forEach(function (color) {\n      return color.unbind();\n    });\n    // Destroy old colors\n    this.colors = [];\n    // Add new colors\n    newColorValues.forEach(function (colorValue) {\n      return this$1.addColor(colorValue);\n    });\n    // Reset active color\n    this.setActiveColor(activeColorIndex);\n    this.emit('color:setAll', this.colors);\n  };\n  // Public ColorPicker events API\n  /**\r\n   * @desc Set a callback function for an event\r\n   * @param eventList event(s) to listen to\r\n   * @param callback - Function called when the event is fired\r\n   */\n  IroColorPicker.prototype.on = function on(eventList, callback) {\n    var this$1 = this;\n    var events = this.events;\n    // eventList can be an eventType string or an array of eventType strings\n    (!Array.isArray(eventList) ? [eventList] : eventList).forEach(function (eventType) {\n      // Add event callback\n      (events[eventType] || (events[eventType] = [])).push(callback);\n      // Call deferred events\n      // These are events that can be stored until a listener for them is added\n      if (this$1.deferredEvents[eventType]) {\n        // Deffered events store an array of arguments from when the event was called\n        this$1.deferredEvents[eventType].forEach(function (args) {\n          callback.apply(null, args);\n        });\n        // Clear deferred events\n        this$1.deferredEvents[eventType] = [];\n      }\n    });\n  };\n  /**\r\n   * @desc Remove a callback function for an event added with on()\r\n   * @param eventList - event(s) to listen to\r\n   * @param callback - original callback function to remove\r\n   */\n  IroColorPicker.prototype.off = function off(eventList, callback) {\n    var this$1 = this;\n    (!Array.isArray(eventList) ? [eventList] : eventList).forEach(function (eventType) {\n      var callbackList = this$1.events[eventType];\n      // this.emitHook('event:off', eventType, callback);\n      if (callbackList) {\n        callbackList.splice(callbackList.indexOf(callback), 1);\n      }\n    });\n  };\n  /**\r\n   * @desc Emit an event\r\n   * @param eventType event to emit\r\n   */\n  IroColorPicker.prototype.emit = function emit(eventType) {\n    var this$1 = this;\n    var args = [],\n      len = arguments.length - 1;\n    while (len-- > 0) args[len] = arguments[len + 1];\n    var activeEvents = this.activeEvents;\n    var isEventActive = activeEvents.hasOwnProperty(eventType) ? activeEvents[eventType] : false;\n    // Prevent event callbacks from firing if the event is already active\n    // This stops infinite loops if something in an event callback causes the same event to be fired again\n    // (e.g. setting the color inside a color:change callback)\n    if (!isEventActive) {\n      activeEvents[eventType] = true;\n      var callbackList = this.events[eventType] || [];\n      callbackList.forEach(function (fn) {\n        return fn.apply(this$1, args);\n      });\n      activeEvents[eventType] = false;\n    }\n  };\n  /**\r\n   * @desc Emit an event now, or save it for when the relevent event listener is added\r\n   * @param eventType - The name of the event to emit\r\n   */\n  IroColorPicker.prototype.deferredEmit = function deferredEmit(eventType) {\n    var ref;\n    var args = [],\n      len = arguments.length - 1;\n    while (len-- > 0) args[len] = arguments[len + 1];\n    var deferredEvents = this.deferredEvents;\n    (ref = this).emit.apply(ref, [eventType].concat(args));\n    (deferredEvents[eventType] || (deferredEvents[eventType] = [])).push(args);\n  };\n  // Public utility methods\n  IroColorPicker.prototype.setOptions = function setOptions(newOptions) {\n    this.setState(newOptions);\n  };\n  /**\r\n   * @desc Resize the color picker\r\n   * @param width - new width\r\n   */\n  IroColorPicker.prototype.resize = function resize(width) {\n    this.setOptions({\n      width: width\n    });\n  };\n  /**\r\n   * @desc Reset the color picker to the initial color provided in the color picker options\r\n   */\n  IroColorPicker.prototype.reset = function reset() {\n    this.colors.forEach(function (color) {\n      return color.reset();\n    });\n    this.setState({\n      colors: this.colors\n    });\n  };\n  /**\r\n   * @desc Called by the createWidget wrapper when the element is mounted into the page\r\n   * @param container - the container element for this ColorPicker instance\r\n   */\n  IroColorPicker.prototype.onMount = function onMount(container) {\n    this.el = container;\n    this.deferredEmit('mount', this);\n  };\n  // Internal methods\n  /**\r\n   * @desc React to a color update\r\n   * @param color - current color\r\n   * @param changes - shows which h,s,v,a color channels changed\r\n   */\n  IroColorPicker.prototype.onColorChange = function onColorChange(color, changes) {\n    this.setState({\n      color: this.color\n    });\n    if (this.inputActive) {\n      this.inputActive = false;\n      this.emit('input:change', color, changes);\n    }\n    this.emit('color:change', color, changes);\n  };\n  /**\r\n   * @desc Handle input from a UI control element\r\n   * @param type - event type\r\n   */\n  IroColorPicker.prototype.emitInputEvent = function emitInputEvent(type, originId) {\n    if (type === 0 /* Start */) {\n      this.emit('input:start', this.color, originId);\n    } else if (type === 1 /* Move */) {\n      this.emit('input:move', this.color, originId);\n    } else if (type === 2 /* End */) {\n      this.emit('input:end', this.color, originId);\n    }\n  };\n  IroColorPicker.prototype.render = function render(props, state) {\n    var this$1 = this;\n    var layout = state.layout;\n    // use layout shorthands\n    if (!Array.isArray(layout)) {\n      switch (layout) {\n        // TODO: implement some?\n        default:\n          layout = [{\n            component: IroWheel\n          }, {\n            component: IroSlider\n          }];\n      }\n      // add transparency slider to the layout\n      if (state.transparency) {\n        layout.push({\n          component: IroSlider,\n          options: {\n            sliderType: 'alpha'\n          }\n        });\n      }\n    }\n    return h(\"div\", {\n      class: \"IroColorPicker\",\n      id: state.id,\n      style: {\n        display: state.display\n      }\n    }, layout.map(function (ref, componentIndex) {\n      var UiComponent = ref.component;\n      var options = ref.options;\n      return h(UiComponent, Object.assign({}, state, options, {\n        ref: undefined,\n        onInput: this$1.emitInputEvent.bind(this$1),\n        parent: this$1,\n        index: componentIndex\n      }));\n    }));\n  };\n  return IroColorPicker;\n}(m);\nIroColorPicker.defaultProps = Object.assign({}, iroColorPickerOptionDefaults, {\n  colors: [],\n  display: 'block',\n  id: null,\n  layout: 'default',\n  margin: null\n});\nvar IroColorPickerWidget = createWidget(IroColorPicker);\nvar iro;\n(function (iro) {\n  iro.version = \"5.5.2\"; // replaced by @rollup/plugin-replace; see rollup.config.js\n  iro.Color = IroColor;\n  iro.ColorPicker = IroColorPickerWidget;\n  var ui;\n  (function (ui) {\n    ui.h = h;\n    ui.ComponentBase = IroComponentWrapper;\n    ui.Handle = IroHandle;\n    ui.Slider = IroSlider;\n    ui.Wheel = IroWheel;\n    ui.Box = IroBox;\n  })(ui = iro.ui || (iro.ui = {}));\n})(iro || (iro = {}));\nvar iro$1 = iro;\nexport default iro$1;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}