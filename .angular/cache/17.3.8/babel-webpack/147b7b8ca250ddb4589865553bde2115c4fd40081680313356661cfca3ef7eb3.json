{"ast":null,"code":"const path = require('path');\nconst sqlite3 = require('./sqlite3-binding.js');\nconst EventEmitter = require('events').EventEmitter;\nmodule.exports = exports = sqlite3;\nfunction normalizeMethod(fn) {\n  return function (sql) {\n    let errBack;\n    const args = Array.prototype.slice.call(arguments, 1);\n    if (typeof args[args.length - 1] === 'function') {\n      const callback = args[args.length - 1];\n      errBack = function (err) {\n        if (err) {\n          callback(err);\n        }\n      };\n    }\n    const statement = new Statement(this, sql, errBack);\n    return fn.call(this, statement, args);\n  };\n}\nfunction inherits(target, source) {\n  for (const k in source.prototype) target.prototype[k] = source.prototype[k];\n}\nsqlite3.cached = {\n  Database: function (file, a, b) {\n    if (file === '' || file === ':memory:') {\n      // Don't cache special databases.\n      return new Database(file, a, b);\n    }\n    let db;\n    file = path.resolve(file);\n    if (!sqlite3.cached.objects[file]) {\n      db = sqlite3.cached.objects[file] = new Database(file, a, b);\n    } else {\n      // Make sure the callback is called.\n      db = sqlite3.cached.objects[file];\n      const callback = typeof a === 'number' ? b : a;\n      if (typeof callback === 'function') {\n        function cb() {\n          callback.call(db, null);\n        }\n        if (db.open) process.nextTick(cb);else db.once('open', cb);\n      }\n    }\n    return db;\n  },\n  objects: {}\n};\nconst Database = sqlite3.Database;\nconst Statement = sqlite3.Statement;\nconst Backup = sqlite3.Backup;\ninherits(Database, EventEmitter);\ninherits(Statement, EventEmitter);\ninherits(Backup, EventEmitter);\n\n// Database#prepare(sql, [bind1, bind2, ...], [callback])\nDatabase.prototype.prepare = normalizeMethod(function (statement, params) {\n  return params.length ? statement.bind.apply(statement, params) : statement;\n});\n\n// Database#run(sql, [bind1, bind2, ...], [callback])\nDatabase.prototype.run = normalizeMethod(function (statement, params) {\n  statement.run.apply(statement, params).finalize();\n  return this;\n});\n\n// Database#get(sql, [bind1, bind2, ...], [callback])\nDatabase.prototype.get = normalizeMethod(function (statement, params) {\n  statement.get.apply(statement, params).finalize();\n  return this;\n});\n\n// Database#all(sql, [bind1, bind2, ...], [callback])\nDatabase.prototype.all = normalizeMethod(function (statement, params) {\n  statement.all.apply(statement, params).finalize();\n  return this;\n});\n\n// Database#each(sql, [bind1, bind2, ...], [callback], [complete])\nDatabase.prototype.each = normalizeMethod(function (statement, params) {\n  statement.each.apply(statement, params).finalize();\n  return this;\n});\nDatabase.prototype.map = normalizeMethod(function (statement, params) {\n  statement.map.apply(statement, params).finalize();\n  return this;\n});\n\n// Database#backup(filename, [callback])\n// Database#backup(filename, destName, sourceName, filenameIsDest, [callback])\nDatabase.prototype.backup = function () {\n  let backup;\n  if (arguments.length <= 2) {\n    // By default, we write the main database out to the main database of the named file.\n    // This is the most likely use of the backup api.\n    backup = new Backup(this, arguments[0], 'main', 'main', true, arguments[1]);\n  } else {\n    // Otherwise, give the user full control over the sqlite3_backup_init arguments.\n    backup = new Backup(this, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);\n  }\n  // Per the sqlite docs, exclude the following errors as non-fatal by default.\n  backup.retryErrors = [sqlite3.BUSY, sqlite3.LOCKED];\n  return backup;\n};\nStatement.prototype.map = function () {\n  const params = Array.prototype.slice.call(arguments);\n  const callback = params.pop();\n  params.push(function (err, rows) {\n    if (err) return callback(err);\n    const result = {};\n    if (rows.length) {\n      const keys = Object.keys(rows[0]);\n      const key = keys[0];\n      if (keys.length > 2) {\n        // Value is an object\n        for (let i = 0; i < rows.length; i++) {\n          result[rows[i][key]] = rows[i];\n        }\n      } else {\n        const value = keys[1];\n        // Value is a plain value\n        for (let i = 0; i < rows.length; i++) {\n          result[rows[i][key]] = rows[i][value];\n        }\n      }\n    }\n    callback(err, result);\n  });\n  return this.all.apply(this, params);\n};\nlet isVerbose = false;\nconst supportedEvents = ['trace', 'profile', 'change'];\nDatabase.prototype.addListener = Database.prototype.on = function (type) {\n  const val = EventEmitter.prototype.addListener.apply(this, arguments);\n  if (supportedEvents.indexOf(type) >= 0) {\n    this.configure(type, true);\n  }\n  return val;\n};\nDatabase.prototype.removeListener = function (type) {\n  const val = EventEmitter.prototype.removeListener.apply(this, arguments);\n  if (supportedEvents.indexOf(type) >= 0 && !this._events[type]) {\n    this.configure(type, false);\n  }\n  return val;\n};\nDatabase.prototype.removeAllListeners = function (type) {\n  const val = EventEmitter.prototype.removeAllListeners.apply(this, arguments);\n  if (supportedEvents.indexOf(type) >= 0) {\n    this.configure(type, false);\n  }\n  return val;\n};\n\n// Save the stack trace over EIO callbacks.\nsqlite3.verbose = function () {\n  if (!isVerbose) {\n    const trace = require('./trace');\n    ['prepare', 'get', 'run', 'all', 'each', 'map', 'close', 'exec'].forEach(function (name) {\n      trace.extendTrace(Database.prototype, name);\n    });\n    ['bind', 'get', 'run', 'all', 'each', 'map', 'reset', 'finalize'].forEach(function (name) {\n      trace.extendTrace(Statement.prototype, name);\n    });\n    isVerbose = true;\n  }\n  return sqlite3;\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}