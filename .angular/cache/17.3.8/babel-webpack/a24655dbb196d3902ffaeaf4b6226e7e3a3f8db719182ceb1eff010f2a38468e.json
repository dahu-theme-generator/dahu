{"ast":null,"code":"import * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Component, ChangeDetectionStrategy, Input, NgModule, Directive, Output, HostListener, EventEmitter, isDevMode, forwardRef } from '@angular/core';\nimport { Subject, Subscription, fromEvent } from 'rxjs';\nimport { distinctUntilChanged, debounceTime, tap } from 'rxjs/operators';\nimport { TinyColor } from '@ctrl/tinycolor';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nfunction EditableInputComponent_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 3);\n    i0.ɵɵlistener(\"mousedown\", function EditableInputComponent_span_2_Template_span_mousedown_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.handleMousedown($event));\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"id\", ctx_r1.uniqueId)(\"ngStyle\", ctx_r1.labelStyle);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.label, \" \");\n  }\n}\nfunction HueComponent_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 2);\n    i0.ɵɵelement(1, \"div\", 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"left\", ctx_r0.left)(\"top\", ctx_r0.top);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngStyle\", ctx_r0.pointer);\n  }\n}\nconst _c0 = [\"*\"];\nfunction SwatchComponent_color_checkboard_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"color-checkboard\", 2);\n  }\n}\nconst checkboardCache = {};\nfunction render(c1, c2, size) {\n  if (typeof document === 'undefined') {\n    return null;\n  }\n  const canvas = document.createElement('canvas');\n  canvas.width = size * 2;\n  canvas.height = size * 2;\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    return null;\n  } // If no context can be found, return early.\n  ctx.fillStyle = c1;\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n  ctx.fillStyle = c2;\n  ctx.fillRect(0, 0, size, size);\n  ctx.translate(size, size);\n  ctx.fillRect(0, 0, size, size);\n  return canvas.toDataURL();\n}\nfunction getCheckerboard(c1, c2, size) {\n  const key = `${c1}-${c2}-${size}`;\n  if (checkboardCache[key]) {\n    return checkboardCache[key];\n  }\n  const checkboard = render(c1, c2, size);\n  if (!checkboard) {\n    return null;\n  }\n  checkboardCache[key] = checkboard;\n  return checkboard;\n}\nlet CheckboardComponent = /*#__PURE__*/(() => {\n  class CheckboardComponent {\n    white = 'transparent';\n    size = 8;\n    grey = 'rgba(0,0,0,.08)';\n    boxShadow;\n    borderRadius;\n    gridStyles;\n    ngOnInit() {\n      const background = getCheckerboard(this.white, this.grey, this.size);\n      this.gridStyles = {\n        borderRadius: this.borderRadius,\n        boxShadow: this.boxShadow,\n        background: `url(${background}) center left`\n      };\n    }\n    static ɵfac = function CheckboardComponent_Factory(t) {\n      return new (t || CheckboardComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: CheckboardComponent,\n      selectors: [[\"color-checkboard\"]],\n      inputs: {\n        white: \"white\",\n        size: \"size\",\n        grey: \"grey\",\n        boxShadow: \"boxShadow\",\n        borderRadius: \"borderRadius\"\n      },\n      decls: 1,\n      vars: 1,\n      consts: [[1, \"grid\", 3, \"ngStyle\"]],\n      template: function CheckboardComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelement(0, \"div\", 0);\n        }\n        if (rf & 2) {\n          i0.ɵɵproperty(\"ngStyle\", ctx.gridStyles);\n        }\n      },\n      dependencies: [i1.NgStyle],\n      styles: [\".grid[_ngcontent-%COMP%]{inset:0;position:absolute}\"],\n      changeDetection: 0\n    });\n  }\n  return CheckboardComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CheckboardModule = /*#__PURE__*/(() => {\n  class CheckboardModule {\n    static ɵfac = function CheckboardModule_Factory(t) {\n      return new (t || CheckboardModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: CheckboardModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [CommonModule]\n    });\n  }\n  return CheckboardModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CoordinatesDirective = /*#__PURE__*/(() => {\n  class CoordinatesDirective {\n    el;\n    coordinatesChange = new Subject();\n    mousechange = new Subject();\n    mouseListening = false;\n    sub;\n    mousemove($event, x, y, isTouch = false) {\n      if (this.mouseListening) {\n        $event.preventDefault();\n        this.mousechange.next({\n          $event,\n          x,\n          y,\n          isTouch\n        });\n      }\n    }\n    mouseup() {\n      this.mouseListening = false;\n    }\n    mousedown($event, x, y, isTouch = false) {\n      $event.preventDefault();\n      this.mouseListening = true;\n      this.mousechange.next({\n        $event,\n        x,\n        y,\n        isTouch\n      });\n    }\n    constructor(el) {\n      this.el = el;\n    }\n    ngOnInit() {\n      this.sub = this.mousechange.pipe(\n      // limit times it is updated for the same area\n      distinctUntilChanged((p, q) => p.x === q.x && p.y === q.y)).subscribe(n => this.handleChange(n.x, n.y, n.$event, n.isTouch));\n    }\n    ngOnDestroy() {\n      this.sub?.unsubscribe();\n    }\n    handleChange(x, y, $event, isTouch) {\n      const containerWidth = this.el.nativeElement.clientWidth;\n      const containerHeight = this.el.nativeElement.clientHeight;\n      const left = x - (this.el.nativeElement.getBoundingClientRect().left + window.pageXOffset);\n      let top = y - this.el.nativeElement.getBoundingClientRect().top;\n      if (!isTouch) {\n        top = top - window.pageYOffset;\n      }\n      this.coordinatesChange.next({\n        x,\n        y,\n        top,\n        left,\n        containerWidth,\n        containerHeight,\n        $event\n      });\n    }\n    static ɵfac = function CoordinatesDirective_Factory(t) {\n      return new (t || CoordinatesDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CoordinatesDirective,\n      selectors: [[\"\", \"ngx-color-coordinates\", \"\"]],\n      hostBindings: function CoordinatesDirective_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"mousemove\", function CoordinatesDirective_mousemove_HostBindingHandler($event) {\n            return ctx.mousemove($event, $event.pageX, $event.pageY);\n          }, false, i0.ɵɵresolveWindow)(\"touchmove\", function CoordinatesDirective_touchmove_HostBindingHandler($event) {\n            return ctx.mousemove($event, $event.touches[0].clientX, $event.touches[0].clientY, true);\n          }, false, i0.ɵɵresolveWindow)(\"mouseup\", function CoordinatesDirective_mouseup_HostBindingHandler() {\n            return ctx.mouseup();\n          }, false, i0.ɵɵresolveWindow)(\"touchend\", function CoordinatesDirective_touchend_HostBindingHandler() {\n            return ctx.mouseup();\n          }, false, i0.ɵɵresolveWindow)(\"mousedown\", function CoordinatesDirective_mousedown_HostBindingHandler($event) {\n            return ctx.mousedown($event, $event.pageX, $event.pageY);\n          })(\"touchstart\", function CoordinatesDirective_touchstart_HostBindingHandler($event) {\n            return ctx.mousedown($event, $event.touches[0].clientX, $event.touches[0].clientY, true);\n          });\n        }\n      },\n      outputs: {\n        coordinatesChange: \"coordinatesChange\"\n      }\n    });\n  }\n  return CoordinatesDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CoordinatesModule = /*#__PURE__*/(() => {\n  class CoordinatesModule {\n    static ɵfac = function CoordinatesModule_Factory(t) {\n      return new (t || CoordinatesModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: CoordinatesModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return CoordinatesModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AlphaComponent = /*#__PURE__*/(() => {\n  class AlphaComponent {\n    hsl;\n    rgb;\n    pointer;\n    shadow;\n    radius;\n    direction = 'horizontal';\n    onChange = new EventEmitter();\n    gradient;\n    pointerLeft;\n    pointerTop;\n    ngOnChanges() {\n      if (this.direction === 'vertical') {\n        this.pointerLeft = 0;\n        this.pointerTop = this.rgb.a * 100;\n        this.gradient = {\n          background: `linear-gradient(to bottom, rgba(${this.rgb.r},${this.rgb.g},${this.rgb.b}, 0) 0%,\n          rgba(${this.rgb.r},${this.rgb.g},${this.rgb.b}, 1) 100%)`\n        };\n      } else {\n        this.gradient = {\n          background: `linear-gradient(to right, rgba(${this.rgb.r},${this.rgb.g},${this.rgb.b}, 0) 0%,\n          rgba(${this.rgb.r},${this.rgb.g},${this.rgb.b}, 1) 100%)`\n        };\n        this.pointerLeft = this.rgb.a * 100;\n      }\n    }\n    handleChange({\n      top,\n      left,\n      containerHeight,\n      containerWidth,\n      $event\n    }) {\n      let data;\n      if (this.direction === 'vertical') {\n        let a;\n        if (top < 0) {\n          a = 0;\n        } else if (top > containerHeight) {\n          a = 1;\n        } else {\n          a = Math.round(top * 100 / containerHeight) / 100;\n        }\n        if (this.hsl.a !== a) {\n          data = {\n            h: this.hsl.h,\n            s: this.hsl.s,\n            l: this.hsl.l,\n            a,\n            source: 'rgb'\n          };\n        }\n      } else {\n        let a;\n        if (left < 0) {\n          a = 0;\n        } else if (left > containerWidth) {\n          a = 1;\n        } else {\n          a = Math.round(left * 100 / containerWidth) / 100;\n        }\n        if (this.hsl.a !== a) {\n          data = {\n            h: this.hsl.h,\n            s: this.hsl.s,\n            l: this.hsl.l,\n            a,\n            source: 'rgb'\n          };\n        }\n      }\n      if (!data) {\n        return;\n      }\n      this.onChange.emit({\n        data,\n        $event\n      });\n    }\n    static ɵfac = function AlphaComponent_Factory(t) {\n      return new (t || AlphaComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: AlphaComponent,\n      selectors: [[\"color-alpha\"]],\n      inputs: {\n        hsl: \"hsl\",\n        rgb: \"rgb\",\n        pointer: \"pointer\",\n        shadow: \"shadow\",\n        radius: \"radius\",\n        direction: \"direction\"\n      },\n      outputs: {\n        onChange: \"onChange\"\n      },\n      features: [i0.ɵɵNgOnChangesFeature],\n      decls: 7,\n      vars: 15,\n      consts: [[1, \"alpha\"], [1, \"alpha-checkboard\"], [1, \"alpha-gradient\", 3, \"ngStyle\"], [\"ngx-color-coordinates\", \"\", 3, \"coordinatesChange\"], [1, \"alpha-pointer\"], [1, \"alpha-slider\", 3, \"ngStyle\"]],\n      template: function AlphaComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1);\n          i0.ɵɵelement(2, \"color-checkboard\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelement(3, \"div\", 2);\n          i0.ɵɵelementStart(4, \"div\", 3);\n          i0.ɵɵlistener(\"coordinatesChange\", function AlphaComponent_Template_div_coordinatesChange_4_listener($event) {\n            return ctx.handleChange($event);\n          });\n          i0.ɵɵelementStart(5, \"div\", 4);\n          i0.ɵɵelement(6, \"div\", 5);\n          i0.ɵɵelementEnd()()();\n        }\n        if (rf & 2) {\n          i0.ɵɵstyleProp(\"border-radius\", ctx.radius);\n          i0.ɵɵadvance(3);\n          i0.ɵɵstyleProp(\"box-shadow\", ctx.shadow)(\"border-radius\", ctx.radius);\n          i0.ɵɵproperty(\"ngStyle\", ctx.gradient);\n          i0.ɵɵadvance();\n          i0.ɵɵclassMapInterpolate1(\"alpha-container color-alpha-\", ctx.direction, \"\");\n          i0.ɵɵadvance();\n          i0.ɵɵstyleProp(\"left\", ctx.pointerLeft, \"%\")(\"top\", ctx.pointerTop, \"%\");\n          i0.ɵɵadvance();\n          i0.ɵɵproperty(\"ngStyle\", ctx.pointer);\n        }\n      },\n      dependencies: [i1.NgStyle, CheckboardComponent, CoordinatesDirective],\n      styles: [\".alpha[_ngcontent-%COMP%]{position:absolute;inset:0}.alpha-checkboard[_ngcontent-%COMP%]{position:absolute;inset:0;overflow:hidden}.alpha-gradient[_ngcontent-%COMP%]{position:absolute;inset:0}.alpha-container[_ngcontent-%COMP%]{position:relative;height:100%;margin:0 3px}.alpha-pointer[_ngcontent-%COMP%]{position:absolute}.alpha-slider[_ngcontent-%COMP%]{width:4px;border-radius:1px;height:8px;box-shadow:0 0 2px #0009;background:#fff;margin-top:1px;transform:translate(-2px)}\"],\n      changeDetection: 0\n    });\n  }\n  return AlphaComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AlphaModule = /*#__PURE__*/(() => {\n  class AlphaModule {\n    static ɵfac = function AlphaModule_Factory(t) {\n      return new (t || AlphaModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: AlphaModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [CommonModule, CheckboardModule, CoordinatesModule]\n    });\n  }\n  return AlphaModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction simpleCheckForValidColor(data) {\n  const keysToCheck = ['r', 'g', 'b', 'a', 'h', 's', 'l', 'v'];\n  let checked = 0;\n  let passed = 0;\n  keysToCheck.forEach(letter => {\n    if (!data[letter]) {\n      return;\n    }\n    checked += 1;\n    if (!isNaN(data[letter])) {\n      passed += 1;\n    }\n    if (letter === 's' || letter === 'l') {\n      const percentPatt = /^\\d+%$/;\n      if (percentPatt.test(data[letter])) {\n        passed += 1;\n      }\n    }\n  });\n  return checked === passed ? data : false;\n}\nfunction toState(data, oldHue, disableAlpha) {\n  const color = data.hex ? new TinyColor(data.hex) : new TinyColor(data);\n  if (disableAlpha) {\n    color.setAlpha(1);\n  }\n  const hsl = color.toHsl();\n  const hsv = color.toHsv();\n  const rgb = color.toRgb();\n  const hex = color.toHex();\n  if (hsl.s === 0) {\n    hsl.h = oldHue || 0;\n    hsv.h = oldHue || 0;\n  }\n  const transparent = hex === '000000' && rgb.a === 0;\n  return {\n    hsl,\n    hex: transparent ? 'transparent' : color.toHexString(),\n    rgb,\n    hsv,\n    oldHue: data.h || oldHue || hsl.h,\n    source: data.source\n  };\n}\nfunction isValidHex(hex) {\n  return new TinyColor(hex).isValid;\n}\nfunction getContrastingColor(data) {\n  if (!data) {\n    return '#fff';\n  }\n  const col = toState(data);\n  if (col.hex === 'transparent') {\n    return 'rgba(0,0,0,0.4)';\n  }\n  const yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1000;\n  return yiq >= 128 ? '#000' : '#fff';\n}\nvar ColorMode = /*#__PURE__*/function (ColorMode) {\n  ColorMode[\"HEX\"] = \"hex\";\n  ColorMode[\"HSL\"] = \"hsl\";\n  ColorMode[\"HSV\"] = \"hsv\";\n  ColorMode[\"RGB\"] = \"rgb\";\n  return ColorMode;\n}(ColorMode || {});\nlet ColorWrap = /*#__PURE__*/(() => {\n  class ColorWrap {\n    className;\n    /**\n     * Descriptors the return color format if the component is used with two-way binding\n     */\n    mode = ColorMode.HEX;\n    color = {\n      h: 250,\n      s: 0.5,\n      l: 0.2,\n      a: 1\n    };\n    colorChange = new EventEmitter();\n    onChange = new EventEmitter();\n    onChangeComplete = new EventEmitter();\n    onSwatchHover = new EventEmitter();\n    oldHue;\n    hsl;\n    hsv;\n    rgb;\n    hex;\n    source;\n    currentColor;\n    changes;\n    disableAlpha;\n    _onChangeCompleteSubscription = new Subscription();\n    _onSwatchHoverSubscription = new Subscription();\n    ngOnInit() {\n      this.changes = this.onChange.pipe(debounceTime(100), tap(event => {\n        this.onChangeComplete.emit(event);\n        switch (this.mode) {\n          case ColorMode.HEX:\n            this.colorChange.emit(event.color.hex);\n            break;\n          case ColorMode.HSL:\n            this.colorChange.emit(event.color.hsl);\n            break;\n          case ColorMode.HSV:\n            this.colorChange.emit(event.color.hsv);\n            break;\n          case ColorMode.RGB:\n            this.colorChange.emit(event.color.rgb);\n            break;\n          default:\n            const msg = `The mode '${this.mode}' is not supported`;\n            if (isDevMode()) {\n              throw new Error(msg);\n            } else {\n              console.warn(msg);\n            }\n            break;\n        }\n      })).subscribe();\n      this.setState(toState(this.color, 0));\n      this.currentColor = this.hex;\n    }\n    ngOnChanges() {\n      this.setState(toState(this.color, this.oldHue));\n    }\n    ngOnDestroy() {\n      this.changes?.unsubscribe();\n      this._onChangeCompleteSubscription?.unsubscribe();\n      this._onSwatchHoverSubscription?.unsubscribe();\n    }\n    setState(data) {\n      this.oldHue = data.oldHue;\n      this.hsl = data.hsl;\n      this.hsv = data.hsv;\n      this.rgb = data.rgb;\n      this.hex = data.hex;\n      this.source = data.source;\n      this.afterValidChange();\n    }\n    handleChange(data, $event) {\n      const isValidColor = simpleCheckForValidColor(data);\n      if (isValidColor) {\n        const color = toState(data, data.h || this.oldHue, this.disableAlpha);\n        this.setState(color);\n        this.onChange.emit({\n          color,\n          $event\n        });\n        this.afterValidChange();\n      }\n    }\n    /** hook for components after a complete change */\n    afterValidChange() {}\n    handleSwatchHover(data, $event) {\n      const isValidColor = simpleCheckForValidColor(data);\n      if (isValidColor) {\n        const color = toState(data, data.h || this.oldHue);\n        this.setState(color);\n        this.onSwatchHover.emit({\n          color,\n          $event\n        });\n      }\n    }\n    registerOnChange(fn) {\n      this._onChangeCompleteSubscription.add(this.onChangeComplete.pipe(tap(event => fn(event.color.hex))).subscribe());\n    }\n    registerOnTouched(fn) {\n      this._onSwatchHoverSubscription.add(this.onSwatchHover.pipe(tap(() => fn())).subscribe());\n    }\n    setDisabledState(isDisabled) {}\n    writeValue(hex) {\n      this.color = hex;\n    }\n    static ɵfac = function ColorWrap_Factory(t) {\n      return new (t || ColorWrap)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: ColorWrap,\n      selectors: [[\"color-wrap\"]],\n      inputs: {\n        className: \"className\",\n        mode: \"mode\",\n        color: \"color\"\n      },\n      outputs: {\n        colorChange: \"colorChange\",\n        onChange: \"onChange\",\n        onChangeComplete: \"onChangeComplete\",\n        onSwatchHover: \"onSwatchHover\"\n      },\n      features: [i0.ɵɵProvidersFeature([{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: forwardRef(() => ColorWrap),\n        multi: true\n      }]), i0.ɵɵNgOnChangesFeature],\n      decls: 0,\n      vars: 0,\n      template: function ColorWrap_Template(rf, ctx) {},\n      encapsulation: 2\n    });\n  }\n  return ColorWrap;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ColorWrapModule = /*#__PURE__*/(() => {\n  class ColorWrapModule {\n    static ɵfac = function ColorWrapModule_Factory(t) {\n      return new (t || ColorWrapModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: ColorWrapModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [CommonModule]\n    });\n  }\n  return ColorWrapModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet nextUniqueId = 0;\nlet EditableInputComponent = /*#__PURE__*/(() => {\n  class EditableInputComponent {\n    style;\n    label;\n    value;\n    arrowOffset;\n    dragLabel;\n    dragMax;\n    placeholder = '';\n    onChange = new EventEmitter();\n    currentValue;\n    blurValue;\n    wrapStyle;\n    inputStyle;\n    labelStyle;\n    focus = false;\n    mousemove;\n    mouseup;\n    uniqueId = `editableInput-${++nextUniqueId}`;\n    ngOnInit() {\n      this.wrapStyle = this.style && this.style.wrap ? this.style.wrap : {};\n      this.inputStyle = this.style && this.style.input ? this.style.input : {};\n      this.labelStyle = this.style && this.style.label ? this.style.label : {};\n      if (this.dragLabel) {\n        this.labelStyle.cursor = 'ew-resize';\n      }\n    }\n    handleFocus($event) {\n      this.focus = true;\n    }\n    handleFocusOut($event) {\n      this.focus = false;\n      this.currentValue = this.blurValue;\n    }\n    handleKeydown($event) {\n      // In case `e.target.value` is a percentage remove the `%` character\n      // and update accordingly with a percentage\n      // https://github.com/casesandberg/react-color/issues/383\n      const stringValue = String($event.target.value);\n      const isPercentage = stringValue.indexOf('%') > -1;\n      const num = Number(stringValue.replace(/%/g, ''));\n      if (isNaN(num)) {\n        return;\n      }\n      const amount = this.arrowOffset || 1;\n      // Up\n      if ($event.keyCode === 38) {\n        if (this.label) {\n          this.onChange.emit({\n            data: {\n              [this.label]: num + amount\n            },\n            $event\n          });\n        } else {\n          this.onChange.emit({\n            data: num + amount,\n            $event\n          });\n        }\n        if (isPercentage) {\n          this.currentValue = `${num + amount}%`;\n        } else {\n          this.currentValue = num + amount;\n        }\n      }\n      // Down\n      if ($event.keyCode === 40) {\n        if (this.label) {\n          this.onChange.emit({\n            data: {\n              [this.label]: num - amount\n            },\n            $event\n          });\n        } else {\n          this.onChange.emit({\n            data: num - amount,\n            $event\n          });\n        }\n        if (isPercentage) {\n          this.currentValue = `${num - amount}%`;\n        } else {\n          this.currentValue = num - amount;\n        }\n      }\n    }\n    handleKeyup($event) {\n      if ($event.keyCode === 40 || $event.keyCode === 38) {\n        return;\n      }\n      if (`${this.currentValue}` === $event.target.value) {\n        return;\n      }\n      if (this.label) {\n        this.onChange.emit({\n          data: {\n            [this.label]: $event.target.value\n          },\n          $event\n        });\n      } else {\n        this.onChange.emit({\n          data: $event.target.value,\n          $event\n        });\n      }\n    }\n    ngOnChanges() {\n      if (!this.focus) {\n        this.currentValue = String(this.value).toUpperCase();\n        this.blurValue = String(this.value).toUpperCase();\n      } else {\n        this.blurValue = String(this.value).toUpperCase();\n      }\n    }\n    ngOnDestroy() {\n      this.unsubscribe();\n    }\n    subscribe() {\n      this.mousemove = fromEvent(document, 'mousemove').subscribe(ev => this.handleDrag(ev));\n      this.mouseup = fromEvent(document, 'mouseup').subscribe(() => this.unsubscribe());\n    }\n    unsubscribe() {\n      this.mousemove?.unsubscribe();\n      this.mouseup?.unsubscribe();\n    }\n    handleMousedown($event) {\n      if (this.dragLabel) {\n        $event.preventDefault();\n        this.handleDrag($event);\n        this.subscribe();\n      }\n    }\n    handleDrag($event) {\n      if (this.dragLabel) {\n        const newValue = Math.round(this.value + $event.movementX);\n        if (newValue >= 0 && newValue <= this.dragMax) {\n          this.onChange.emit({\n            data: {\n              [this.label]: newValue\n            },\n            $event\n          });\n        }\n      }\n    }\n    static ɵfac = function EditableInputComponent_Factory(t) {\n      return new (t || EditableInputComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: EditableInputComponent,\n      selectors: [[\"color-editable-input\"]],\n      inputs: {\n        style: \"style\",\n        label: \"label\",\n        value: \"value\",\n        arrowOffset: \"arrowOffset\",\n        dragLabel: \"dragLabel\",\n        dragMax: \"dragMax\",\n        placeholder: \"placeholder\"\n      },\n      outputs: {\n        onChange: \"onChange\"\n      },\n      features: [i0.ɵɵNgOnChangesFeature],\n      decls: 3,\n      vars: 6,\n      consts: [[1, \"wrap\", 3, \"ngStyle\"], [\"spellCheck\", \"false\", 3, \"keydown\", \"keyup\", \"focus\", \"focusout\", \"ngStyle\", \"value\", \"placeholder\"], [3, \"id\", \"ngStyle\", \"mousedown\", 4, \"ngIf\"], [3, \"mousedown\", \"id\", \"ngStyle\"]],\n      template: function EditableInputComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"div\", 0)(1, \"input\", 1);\n          i0.ɵɵlistener(\"keydown\", function EditableInputComponent_Template_input_keydown_1_listener($event) {\n            return ctx.handleKeydown($event);\n          })(\"keyup\", function EditableInputComponent_Template_input_keyup_1_listener($event) {\n            return ctx.handleKeyup($event);\n          })(\"focus\", function EditableInputComponent_Template_input_focus_1_listener($event) {\n            return ctx.handleFocus($event);\n          })(\"focusout\", function EditableInputComponent_Template_input_focusout_1_listener($event) {\n            return ctx.handleFocusOut($event);\n          });\n          i0.ɵɵelementEnd();\n          i0.ɵɵtemplate(2, EditableInputComponent_span_2_Template, 2, 3, \"span\", 2);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵproperty(\"ngStyle\", ctx.wrapStyle);\n          i0.ɵɵadvance();\n          i0.ɵɵproperty(\"ngStyle\", ctx.inputStyle)(\"value\", ctx.currentValue)(\"placeholder\", ctx.placeholder);\n          i0.ɵɵattribute(\"aria-labelledby\", ctx.uniqueId);\n          i0.ɵɵadvance();\n          i0.ɵɵproperty(\"ngIf\", ctx.label);\n        }\n      },\n      dependencies: [i1.NgIf, i1.NgStyle],\n      styles: [\"[_nghost-%COMP%]{display:flex}.wrap[_ngcontent-%COMP%]{position:relative}\"],\n      changeDetection: 0\n    });\n  }\n  return EditableInputComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet EditableInputModule = /*#__PURE__*/(() => {\n  class EditableInputModule {\n    static ɵfac = function EditableInputModule_Factory(t) {\n      return new (t || EditableInputModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: EditableInputModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [CommonModule]\n    });\n  }\n  return EditableInputModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HueComponent = /*#__PURE__*/(() => {\n  class HueComponent {\n    hsl;\n    pointer;\n    radius;\n    shadow;\n    hidePointer = false;\n    direction = 'horizontal';\n    onChange = new EventEmitter();\n    left = '0px';\n    top = '';\n    ngOnChanges() {\n      if (this.direction === 'horizontal') {\n        this.left = `${this.hsl.h * 100 / 360}%`;\n      } else {\n        this.top = `${-(this.hsl.h * 100 / 360) + 100}%`;\n      }\n    }\n    handleChange({\n      top,\n      left,\n      containerHeight,\n      containerWidth,\n      $event\n    }) {\n      let data;\n      if (this.direction === 'vertical') {\n        let h;\n        if (top < 0) {\n          h = 359;\n        } else if (top > containerHeight) {\n          h = 0;\n        } else {\n          const percent = -(top * 100 / containerHeight) + 100;\n          h = 360 * percent / 100;\n        }\n        if (this.hsl.h !== h) {\n          data = {\n            h,\n            s: this.hsl.s,\n            l: this.hsl.l,\n            a: this.hsl.a,\n            source: 'rgb'\n          };\n        }\n      } else {\n        let h;\n        if (left < 0) {\n          h = 0;\n        } else if (left > containerWidth) {\n          h = 359;\n        } else {\n          const percent = left * 100 / containerWidth;\n          h = 360 * percent / 100;\n        }\n        if (this.hsl.h !== h) {\n          data = {\n            h,\n            s: this.hsl.s,\n            l: this.hsl.l,\n            a: this.hsl.a,\n            source: 'rgb'\n          };\n        }\n      }\n      if (!data) {\n        return;\n      }\n      this.onChange.emit({\n        data,\n        $event\n      });\n    }\n    static ɵfac = function HueComponent_Factory(t) {\n      return new (t || HueComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: HueComponent,\n      selectors: [[\"color-hue\"]],\n      inputs: {\n        hsl: \"hsl\",\n        pointer: \"pointer\",\n        radius: \"radius\",\n        shadow: \"shadow\",\n        hidePointer: \"hidePointer\",\n        direction: \"direction\"\n      },\n      outputs: {\n        onChange: \"onChange\"\n      },\n      features: [i0.ɵɵNgOnChangesFeature],\n      decls: 3,\n      vars: 8,\n      consts: [[\"ngx-color-coordinates\", \"\", 1, \"color-hue-container\", 3, \"coordinatesChange\"], [\"class\", \"color-hue-pointer\", 3, \"left\", \"top\", 4, \"ngIf\"], [1, \"color-hue-pointer\"], [1, \"color-hue-slider\", 3, \"ngStyle\"]],\n      template: function HueComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"div\")(1, \"div\", 0);\n          i0.ɵɵlistener(\"coordinatesChange\", function HueComponent_Template_div_coordinatesChange_1_listener($event) {\n            return ctx.handleChange($event);\n          });\n          i0.ɵɵtemplate(2, HueComponent_div_2_Template, 2, 5, \"div\", 1);\n          i0.ɵɵelementEnd()();\n        }\n        if (rf & 2) {\n          i0.ɵɵclassMapInterpolate1(\"color-hue color-hue-\", ctx.direction, \"\");\n          i0.ɵɵstyleProp(\"border-radius\", ctx.radius, \"px\")(\"box-shadow\", ctx.shadow);\n          i0.ɵɵadvance(2);\n          i0.ɵɵproperty(\"ngIf\", !ctx.hidePointer);\n        }\n      },\n      dependencies: [i1.NgIf, i1.NgStyle, CoordinatesDirective],\n      styles: [\".color-hue[_ngcontent-%COMP%]{position:absolute;inset:0}.color-hue-container[_ngcontent-%COMP%]{margin:0 2px;position:relative;height:100%}.color-hue-pointer[_ngcontent-%COMP%]{position:absolute}.color-hue-slider[_ngcontent-%COMP%]{margin-top:1px;width:4px;border-radius:1px;height:8px;box-shadow:0 0 2px #0009;background:#fff;transform:translate(-2px)}.color-hue-horizontal[_ngcontent-%COMP%]{background:linear-gradient(to right,#f00 0%,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,#f00 100%)}.color-hue-vertical[_ngcontent-%COMP%]{background:linear-gradient(to top,#f00 0%,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,#f00 100%)}\"],\n      changeDetection: 0\n    });\n  }\n  return HueComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HueModule = /*#__PURE__*/(() => {\n  class HueModule {\n    static ɵfac = function HueModule_Factory(t) {\n      return new (t || HueModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: HueModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [CommonModule, CoordinatesModule]\n    });\n  }\n  return HueModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RaisedComponent = /*#__PURE__*/(() => {\n  class RaisedComponent {\n    zDepth = 1;\n    radius = 1;\n    background = '#fff';\n    static ɵfac = function RaisedComponent_Factory(t) {\n      return new (t || RaisedComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: RaisedComponent,\n      selectors: [[\"color-raised\"]],\n      inputs: {\n        zDepth: \"zDepth\",\n        radius: \"radius\",\n        background: \"background\"\n      },\n      ngContentSelectors: _c0,\n      decls: 4,\n      vars: 5,\n      consts: [[1, \"raised-wrap\"], [1, \"raised-content\"]],\n      template: function RaisedComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵelementStart(0, \"div\", 0);\n          i0.ɵɵelement(1, \"div\");\n          i0.ɵɵelementStart(2, \"div\", 1);\n          i0.ɵɵprojection(3);\n          i0.ɵɵelementEnd()();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance();\n          i0.ɵɵclassMapInterpolate1(\"raised-bg zDepth-\", ctx.zDepth, \"\");\n          i0.ɵɵstyleProp(\"background\", ctx.background);\n        }\n      },\n      styles: [\".raised-wrap[_ngcontent-%COMP%]{position:relative;display:inline-block}.raised-bg[_ngcontent-%COMP%]{position:absolute;inset:0}.raised-content[_ngcontent-%COMP%]{position:relative}.zDepth-0[_ngcontent-%COMP%]{box-shadow:none}.zDepth-1[_ngcontent-%COMP%]{box-shadow:0 2px 10px #0000001f,0 2px 5px #00000029}.zDepth-2[_ngcontent-%COMP%]{box-shadow:0 6px 20px #00000030,0 8px 17px #0003}.zDepth-3[_ngcontent-%COMP%]{box-shadow:0 17px 50px #00000030,0 12px 15px #0000003d}.zDepth-4[_ngcontent-%COMP%]{box-shadow:0 25px 55px #00000036,0 16px 28px #00000038}.zDepth-5[_ngcontent-%COMP%]{box-shadow:0 40px 77px #00000038,0 27px 24px #0003}\"],\n      changeDetection: 0\n    });\n  }\n  return RaisedComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RaisedModule = /*#__PURE__*/(() => {\n  class RaisedModule {\n    static ɵfac = function RaisedModule_Factory(t) {\n      return new (t || RaisedModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: RaisedModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [CommonModule]\n    });\n  }\n  return RaisedModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SaturationComponent = /*#__PURE__*/(() => {\n  class SaturationComponent {\n    hsl;\n    hsv;\n    radius;\n    pointer;\n    circle;\n    onChange = new EventEmitter();\n    background;\n    pointerTop;\n    pointerLeft;\n    ngOnChanges() {\n      this.background = `hsl(${this.hsl.h}, 100%, 50%)`;\n      this.pointerTop = -(this.hsv.v * 100) + 1 + 100 + '%';\n      this.pointerLeft = this.hsv.s * 100 + '%';\n    }\n    handleChange({\n      top,\n      left,\n      containerHeight,\n      containerWidth,\n      $event\n    }) {\n      if (left < 0) {\n        left = 0;\n      } else if (left > containerWidth) {\n        left = containerWidth;\n      } else if (top < 0) {\n        top = 0;\n      } else if (top > containerHeight) {\n        top = containerHeight;\n      }\n      const saturation = left / containerWidth;\n      let bright = -(top / containerHeight) + 1;\n      bright = bright > 0 ? bright : 0;\n      bright = bright > 1 ? 1 : bright;\n      const data = {\n        h: this.hsl.h,\n        s: saturation,\n        v: bright,\n        a: this.hsl.a,\n        source: 'hsva'\n      };\n      this.onChange.emit({\n        data,\n        $event\n      });\n    }\n    static ɵfac = function SaturationComponent_Factory(t) {\n      return new (t || SaturationComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: SaturationComponent,\n      selectors: [[\"color-saturation\"]],\n      inputs: {\n        hsl: \"hsl\",\n        hsv: \"hsv\",\n        radius: \"radius\",\n        pointer: \"pointer\",\n        circle: \"circle\"\n      },\n      outputs: {\n        onChange: \"onChange\"\n      },\n      features: [i0.ɵɵNgOnChangesFeature],\n      decls: 5,\n      vars: 8,\n      consts: [[\"ngx-color-coordinates\", \"\", 1, \"color-saturation\", 3, \"coordinatesChange\"], [1, \"saturation-white\"], [1, \"saturation-black\"], [1, \"saturation-pointer\", 3, \"ngStyle\"], [1, \"saturation-circle\", 3, \"ngStyle\"]],\n      template: function SaturationComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"div\", 0);\n          i0.ɵɵlistener(\"coordinatesChange\", function SaturationComponent_Template_div_coordinatesChange_0_listener($event) {\n            return ctx.handleChange($event);\n          });\n          i0.ɵɵelementStart(1, \"div\", 1);\n          i0.ɵɵelement(2, \"div\", 2);\n          i0.ɵɵelementStart(3, \"div\", 3);\n          i0.ɵɵelement(4, \"div\", 4);\n          i0.ɵɵelementEnd()()();\n        }\n        if (rf & 2) {\n          i0.ɵɵstyleProp(\"background\", ctx.background);\n          i0.ɵɵadvance(3);\n          i0.ɵɵstyleProp(\"top\", ctx.pointerTop)(\"left\", ctx.pointerLeft);\n          i0.ɵɵproperty(\"ngStyle\", ctx.pointer);\n          i0.ɵɵadvance();\n          i0.ɵɵproperty(\"ngStyle\", ctx.circle);\n        }\n      },\n      dependencies: [i1.NgStyle, CoordinatesDirective],\n      styles: [\".saturation-white[_ngcontent-%COMP%]{background:linear-gradient(to right,#fff,rgba(255,255,255,0));position:absolute;inset:0}.saturation-black[_ngcontent-%COMP%]{background:linear-gradient(to top,#000,rgba(0,0,0,0));position:absolute;inset:0}.color-saturation[_ngcontent-%COMP%]{position:absolute;inset:0}.saturation-pointer[_ngcontent-%COMP%]{position:absolute;cursor:default}.saturation-circle[_ngcontent-%COMP%]{width:4px;height:4px;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px #0000004d,0 0 1px 2px #0006;border-radius:50%;cursor:hand;transform:translate(-2px,-4px)}\"],\n      changeDetection: 0\n    });\n  }\n  return SaturationComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SaturationModule = /*#__PURE__*/(() => {\n  class SaturationModule {\n    static ɵfac = function SaturationModule_Factory(t) {\n      return new (t || SaturationModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: SaturationModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [CommonModule, CoordinatesModule]\n    });\n  }\n  return SaturationModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SwatchComponent = /*#__PURE__*/(() => {\n  class SwatchComponent {\n    color;\n    style = {};\n    focusStyle = {};\n    focus;\n    onClick = new EventEmitter();\n    onHover = new EventEmitter();\n    divStyles = {};\n    focusStyles = {};\n    inFocus = false;\n    ngOnInit() {\n      this.divStyles = {\n        background: this.color,\n        ...this.style\n      };\n    }\n    currentStyles() {\n      this.focusStyles = {\n        ...this.divStyles,\n        ...this.focusStyle\n      };\n      return this.focus || this.inFocus ? this.focusStyles : this.divStyles;\n    }\n    handleFocusOut() {\n      this.inFocus = false;\n    }\n    handleFocus() {\n      this.inFocus = true;\n    }\n    handleHover(hex, $event) {\n      this.onHover.emit({\n        hex,\n        $event\n      });\n    }\n    handleClick(hex, $event) {\n      this.onClick.emit({\n        hex,\n        $event\n      });\n    }\n    static ɵfac = function SwatchComponent_Factory(t) {\n      return new (t || SwatchComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: SwatchComponent,\n      selectors: [[\"color-swatch\"]],\n      inputs: {\n        color: \"color\",\n        style: \"style\",\n        focusStyle: \"focusStyle\",\n        focus: \"focus\"\n      },\n      outputs: {\n        onClick: \"onClick\",\n        onHover: \"onHover\"\n      },\n      ngContentSelectors: _c0,\n      decls: 3,\n      vars: 3,\n      consts: [[\"tabindex\", \"0\", 1, \"swatch\", 3, \"click\", \"keydown.enter\", \"focus\", \"blur\", \"mouseover\", \"ngStyle\"], [\"boxShadow\", \"inset 0 0 0 1px rgba(0,0,0,0.1)\", 4, \"ngIf\"], [\"boxShadow\", \"inset 0 0 0 1px rgba(0,0,0,0.1)\"]],\n      template: function SwatchComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵelementStart(0, \"div\", 0);\n          i0.ɵɵlistener(\"click\", function SwatchComponent_Template_div_click_0_listener($event) {\n            return ctx.handleClick(ctx.color, $event);\n          })(\"keydown.enter\", function SwatchComponent_Template_div_keydown_enter_0_listener($event) {\n            return ctx.handleClick(ctx.color, $event);\n          })(\"focus\", function SwatchComponent_Template_div_focus_0_listener() {\n            return ctx.handleFocus();\n          })(\"blur\", function SwatchComponent_Template_div_blur_0_listener() {\n            return ctx.handleFocusOut();\n          })(\"mouseover\", function SwatchComponent_Template_div_mouseover_0_listener($event) {\n            return ctx.handleHover(ctx.color, $event);\n          });\n          i0.ɵɵprojection(1);\n          i0.ɵɵtemplate(2, SwatchComponent_color_checkboard_2_Template, 1, 0, \"color-checkboard\", 1);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵproperty(\"ngStyle\", ctx.currentStyles());\n          i0.ɵɵattribute(\"title\", ctx.color);\n          i0.ɵɵadvance(2);\n          i0.ɵɵproperty(\"ngIf\", ctx.color === \"transparent\");\n        }\n      },\n      dependencies: [i1.NgIf, i1.NgStyle, CheckboardComponent],\n      styles: [\".swatch[_ngcontent-%COMP%]{outline:none;height:100%;width:100%;cursor:pointer;position:relative}\"],\n      changeDetection: 0\n    });\n  }\n  return SwatchComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SwatchModule = /*#__PURE__*/(() => {\n  class SwatchModule {\n    static ɵfac = function SwatchModule_Factory(t) {\n      return new (t || SwatchModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: SwatchModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [CommonModule, CheckboardModule]\n    });\n  }\n  return SwatchModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ShadeComponent = /*#__PURE__*/(() => {\n  class ShadeComponent {\n    hsl;\n    rgb;\n    pointer;\n    shadow;\n    radius;\n    onChange = new EventEmitter();\n    gradient;\n    pointerLeft;\n    pointerTop;\n    ngOnChanges() {\n      this.gradient = {\n        background: `linear-gradient(to right,\n          hsl(${this.hsl.h}, 90%, 55%),\n          #000)`\n      };\n      const hsv = new TinyColor(this.hsl).toHsv();\n      this.pointerLeft = 100 - hsv.v * 100;\n    }\n    handleChange({\n      left,\n      containerWidth,\n      $event\n    }) {\n      let data;\n      let v;\n      if (left < 0) {\n        v = 0;\n      } else if (left > containerWidth) {\n        v = 1;\n      } else {\n        v = Math.round(left * 100 / containerWidth) / 100;\n      }\n      const hsv = new TinyColor(this.hsl).toHsv();\n      if (hsv.v !== v) {\n        data = {\n          h: this.hsl.h,\n          s: 100,\n          v: 1 - v,\n          l: this.hsl.l,\n          a: this.hsl.a,\n          source: 'rgb'\n        };\n      }\n      if (!data) {\n        return;\n      }\n      this.onChange.emit({\n        data,\n        $event\n      });\n    }\n    static ɵfac = function ShadeComponent_Factory(t) {\n      return new (t || ShadeComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: ShadeComponent,\n      selectors: [[\"color-shade\"]],\n      inputs: {\n        hsl: \"hsl\",\n        rgb: \"rgb\",\n        pointer: \"pointer\",\n        shadow: \"shadow\",\n        radius: \"radius\"\n      },\n      outputs: {\n        onChange: \"onChange\"\n      },\n      features: [i0.ɵɵNgOnChangesFeature],\n      decls: 5,\n      vars: 12,\n      consts: [[1, \"shade\"], [1, \"shade-gradient\", 3, \"ngStyle\"], [\"ngx-color-coordinates\", \"\", 1, \"shade-container\", 3, \"coordinatesChange\"], [1, \"shade-pointer\"], [1, \"shade-slider\", 3, \"ngStyle\"]],\n      template: function ShadeComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"div\", 0);\n          i0.ɵɵelement(1, \"div\", 1);\n          i0.ɵɵelementStart(2, \"div\", 2);\n          i0.ɵɵlistener(\"coordinatesChange\", function ShadeComponent_Template_div_coordinatesChange_2_listener($event) {\n            return ctx.handleChange($event);\n          });\n          i0.ɵɵelementStart(3, \"div\", 3);\n          i0.ɵɵelement(4, \"div\", 4);\n          i0.ɵɵelementEnd()()();\n        }\n        if (rf & 2) {\n          i0.ɵɵstyleProp(\"border-radius\", ctx.radius);\n          i0.ɵɵadvance();\n          i0.ɵɵstyleProp(\"box-shadow\", ctx.shadow)(\"border-radius\", ctx.radius);\n          i0.ɵɵproperty(\"ngStyle\", ctx.gradient);\n          i0.ɵɵadvance(2);\n          i0.ɵɵstyleProp(\"left\", ctx.pointerLeft, \"%\")(\"top\", ctx.pointerTop, \"%\");\n          i0.ɵɵadvance();\n          i0.ɵɵproperty(\"ngStyle\", ctx.pointer);\n        }\n      },\n      dependencies: [i1.NgStyle, CoordinatesDirective],\n      styles: [\".shade[_ngcontent-%COMP%], .shade-gradient[_ngcontent-%COMP%]{position:absolute;inset:0}.shade-container[_ngcontent-%COMP%]{position:relative;height:100%;margin:0 3px}.shade-pointer[_ngcontent-%COMP%]{position:absolute}.shade-slider[_ngcontent-%COMP%]{width:4px;border-radius:1px;height:8px;box-shadow:0 0 2px #0009;background:#fff;margin-top:1px;transform:translate(-2px)}\"],\n      changeDetection: 0\n    });\n  }\n  return ShadeComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ShadeModule = /*#__PURE__*/(() => {\n  class ShadeModule {\n    static ɵfac = function ShadeModule_Factory(t) {\n      return new (t || ShadeModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: ShadeModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [CommonModule, CoordinatesModule]\n    });\n  }\n  return ShadeModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AlphaComponent, AlphaModule, CheckboardComponent, CheckboardModule, ColorMode, ColorWrap, ColorWrapModule, CoordinatesDirective, CoordinatesModule, EditableInputComponent, EditableInputModule, HueComponent, HueModule, RaisedComponent, RaisedModule, SaturationComponent, SaturationModule, ShadeComponent, ShadeModule, SwatchComponent, SwatchModule, getCheckerboard, getContrastingColor, isValidHex, render, simpleCheckForValidColor, toState };\n//# sourceMappingURL=ngx-color.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}