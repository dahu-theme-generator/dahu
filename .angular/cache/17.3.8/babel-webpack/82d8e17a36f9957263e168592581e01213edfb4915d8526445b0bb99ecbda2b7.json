{"ast":null,"code":"import _asyncToGenerator from \"/home/andojas/Documents/dahu/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _wrapAsyncGenerator from \"/home/andojas/Documents/dahu/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"/home/andojas/Documents/dahu/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"/home/andojas/Documents/dahu/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/home/andojas/Documents/dahu/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nexport const streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n  let pos = 0;\n  let end;\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n};\nexport const readBytes = /*#__PURE__*/function () {\n  var _ref = _wrapAsyncGenerator(function* (iterable, chunkSize, encode) {\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(iterable), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n        const chunk = _step.value;\n        {\n          yield* _asyncGeneratorDelegate(_asyncIterator(streamChunk(ArrayBuffer.isView(chunk) ? chunk : yield _awaitAsyncGenerator(encode(String(chunk))), chunkSize)), _awaitAsyncGenerator);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          yield _awaitAsyncGenerator(_iterator.return());\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n  return function readBytes(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport const trackStream = (stream, chunkSize, onProgress, onFinish, encode) => {\n  const iterator = readBytes(stream, chunkSize, encode);\n  let bytes = 0;\n  return new ReadableStream({\n    type: 'bytes',\n    pull(controller) {\n      return _asyncToGenerator(function* () {\n        const {\n          done,\n          value\n        } = yield iterator.next();\n        if (done) {\n          controller.close();\n          onFinish();\n          return;\n        }\n        let len = value.byteLength;\n        onProgress && onProgress(bytes += len);\n        controller.enqueue(new Uint8Array(value));\n      })();\n    },\n    cancel(reason) {\n      onFinish(reason);\n      return iterator.return();\n    }\n  }, {\n    highWaterMark: 2\n  });\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}